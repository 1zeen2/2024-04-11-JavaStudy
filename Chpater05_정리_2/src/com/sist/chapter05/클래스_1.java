package com.sist.chapter05;
/*
 * 	변수 : 한 개 저장 메모리 공간
 * 		= 데이터 형
 * 			정수 :	int, long, 배열(byte) => 네트워크 전송, 파일 읽기
 * 			사용자 정의 클래스
 * 			--------------- + 기본 데이터 형 들을 조합.
 * 			
 * 
 * 		= 배열 =>	같은 데이터 형의 변수 여러 개를 한 번에 저장(이름이 한 개) => 인덱스(0...)
 * 				 	같은 데이터 형만 모아서 관리한다 / 저장 개수를 지정 (고정)
 * 
 * 		= 클래스 =>	다른 데이터 형을 저장할 수 있다.
 * 					저장 개수를 지정하지 않는다.
 * 					=>	필요한 개수만큼 new를 사용한다.
 * 					=>	한 개에 대한 정보 (영화 정보 / 뮤직 정보 ...)
 * 						----- new를 통해 메모리에 저장.
 * 	----------------------------------------------------------------------------------------------
 * 	연산 처리 / 제어문 처리
 * 	--------------------- 메서드 (기능 처리)
 * 	누가 얼마나 잘 묶어서 재사용을 잘 할 수 있는가에 따라 실력이 나뉨.
 * 		=> 변수 : 배열 / 클래스
 * 			=> 초기화 (생성자)
 * 
 * 		=> 명령문 (연산 / 제어문)을 묶은 것 => 메서드
 * 
 * 	클래스 구성 요소
 * 	1. 변수 (멤버 변수)
 * 	2. 메서드			==> 변수에 대한 활용 ==> 어떻게 활용을 할 것 인가.
 * 	3. 생성자			==> 변수 초기화 		==> 어떻게 초기화를 할 것 인가.
 * 	------------------------------------------------------------------------
 * 	클래스는 한 가지 기능을 한다 ==> 프로그램에서는 여러 가지 기능이 필요하다
 * 		===> 클래스여러 개를 만들어 연결을 해야 함.
 * 								  ----- =>	접근 범위에 따라 어떤 것은 연결이 되고 어떤 것은 연결이 되지 않게 지정해야 함.
 * 											[접근 지정자]
 * 	--------------------------------------------------------------------------------------------------------------------
 * 	재사용 기법
 * 	----------
 * 	= 상속 (변경해서 사용하는 것을 의미함)
 * 		class A
 * 		class B extends A		=> is - a
 * 				
 * 		class C {
 * 			A a = new A();		=> has - a
 * 		}
 * 
 * 	= 포함 (있는 그대로 사용하는 것을 의미함)
 * 	
 * 	= 상황에 맞게 변경 / 새로운 기능 추가 ==> 유지 보수가 좋음
 * 			 오버로딩 / 오버라이딩
 * 	---------------------------------------------------------
 * 	1. 캡슐화		: 데이터 보호
 * 	2. 상속 / 포함	: 재사용
 * 	3. 다형성		: 오버 라이딩 / 오버 로딩
 * 					  ----------   --------
 * 						  |			   |=> 새로운 기능
 * 						  |=> 수정			 (new)
 * 							(modify)
 * 
 * 	4. 추상화		:	사물을 단순화 하는 것 ==> 클래스의 기본이다.
 * 		사원 = 사번, 이름, 부서
 * 		학생 = 학번, 이름, 학교
 * 		---------------------- 추상화 기법.
 * 	------------------------------------------------------------ 클래스의 종류
 * 		일반 클래스
 * 		추상 클래스 / 인터페이스 : 미완성 => 개발자가 완성해서 사용
 * 			(예시)
 * 				글쓰기
 * 				상세 보기
 * 				찾기
 * 				수정
 * 				기능 추가
 * 				...
 * 		----------------------
 * 		메서드가 미구현 : 프로그램에 맞게 구현해서 사용
 * 		=> (예시) 버튼 클릭
 * 	---------------------------------------------------------
 * 	프로그램의 안정성 => 종료하지 않는 프로그램 => 예외 처리 
 *
 *	라이브러리를 잘 조립하려면 => 암기를 잘 해야 한다
 *	Math => random() / ceil()
 *		=> Collection 
 *	----------------------------------------------------------------
 *	세부적으로 공부한다면
 *		클래스 :	변수, 메서드, 생성자, 접근 지정어
 *				----  -----	 ------	 ----------
 *				 |		|      |		 |=> private	=> 변수
 *				 |      |      |		 	 public		=> 나머지;
 *				 |		|      |
 *				 |		|      |=> 생성자, 초기화 블럭 => 동시에 사용하지는 않는다.
 *				 |		|
 *				 |		|=>	인스턴스 메서드, static 메서드, 선언만 하는 메서드
 *				 |	
 *				 |=> 인스턴스 변수, static 변수, 지역 변수
 *	
 *	클래스의 구성 요소를 전부 사용해야 하는 것은 아니다.
 *	----------------- 필요한 것만 사용하면 된다.
 *
 *	** 순서는 상관 없지만	 권장하는 순서는 있음.
 *		=>	변수
 * 		=>	생성자	
 * 		=>	메서드
 * 	class ClassName {
 * 		--------- 변수	 선언 ---------
 * 		[접근 지정어] [옵션 지정어] 데이터 형 변수 명 ==> 노출 방지
 * 		private		  static
 * 					  final
 * 					  abstract (메서드에서만 사용)
 * 					  synchronized (메서드에서만 사용)
 * 
 * 		인스턴스 변수
 * 		정적 변수 (static) => 공통으로 사용되는 변수 => Method Area => 메모리 공간을 한 개만 사용
 * 
 * 		*** 대부분은 인스턴스 변수만 사용한다.
 * 		*** 클래스 안에는 변수가 없는 경우도 있다. (필요한 경우에만 사용)
 * 		*** 변수 => 저장할 때 반드시 값을 필요로 한다.
 * 					----------------- 초기 값
 * 
 * 		클래스 영역에 설장되는 변수는 default 값으로 자동 초기화.
 * 			=> 프로그램에 따라서 다른 초기 값이 필요할 수도 있다
 * 			=> 난수 발생, 사용자의 입력 값 ==> 클래스 블럭에서는 사용할 수 없다. ==> 때문에 생성자를 제공함.
 * 
 * 		--------- 생성자	 선언 ---------
 * 		=> 명시적인 초기화가 불가능한 경우 (구현을 통해 값을 가지고 오는 경우)
 * 		=> 멤버 변수의 초기화
 * 		=> 시작과 동시에 처리하는 명령문이 존재할 때
 * 		   	=> 화면 UI / 자동 로그인 / 서버에 연결 / 서버 가동 / 데이터베이스 연동
 * 		=> 없는 경우에는 생략할 수 있다 : 프로그램 구동 시에는 반드시 생성자가 필요하다
 * 										------------------------------------------
 * 										 => 컴파일러에 의해 자동 추가 (default) 생성자 ===> 매개 변수가 없는 생성자이다.
 * 		=> 특징
 * 			=> 클래스 명과 동일
 * 			=> 리턴 형이 없다.
 * 			=> 객체 생성 시에 호출 => new를 동반한다.
 * 			=> 여러 개의 생성자를 만들 수 있다.
 * 			   --------------- 오버로딩 ==> 중복 함수 정의
 * 				구분) => 	매개 변수를 통해 구분한다.
 * 				class A {	---------
 * 					A(){}	1. 개수가 다르다
 * 					A(){}	2. 데이터 형이 다르다
 * 					A(){}	-------------------- 접근 지정어, 리턴 형과는 관계가 없다.	====> JVM이 알아서 찾아줌.
 * 					A(){}
 * 					A(){}
				}
				
				A a = new A(); // 생성자 호출 ==> class 의 인스턴스 a 생성.
 * 
 * 			=> 오버로딩
 * 				void display(int char double)
 * 				void display(int char int)
 * 				void display(double	double double)
 * 				void display(char int int)
 * 
 * 				display(10.5, 'a', 10) ===> 딱 맞는 데이터 형으로 찾아가는 것이 1순위, 강제 형변환 없이 들어갈 수 있는 데이터 형 타입으로 찾아가는 것이 2순위이다.
 * 
 * 				class A {
 * 					public void display(){}
 * 
 * 				A a = new A()
 * 				a.display()
 * 				}
 * 				new A().display();
 * 
 * 		** 생성자는 다른 클래스에 연결 시에 사용한다. => public
 * 		** 객체 지향 프로그램은 클래스 1개로 제작 하는 것이 아니라 클래스 여러 개를 만들어 연결하며 쓰는 것 이다.
 * 				
 * 
 * 
 * 		--------- 메서드	 선언 ---------
 * 	------------------------------------------------------------------------
 * 	}
 * 
 * 	접근 지정어
 * 	----------
 * 
 * 
 * 
 * 
 */
public class 클래스_1 {
	void display(int a) {
		System.out.println("display int call...");
	}
	static void display(double d) {
		System.out.println("display double call...");
	}

	public static void main(String[] args) {
		클래스_1 a = new  클래스_1();	// 
		a.display(100);					//
		
		new 클래스_1().display(100);
		new 클래스_1().display('a');
		display(45.45);
		
		
		int aa = 10;
		System.out.println(aa);
		System.out.println(10);
	}

}
