package com.sist.main;
/*
 *   5장 
 *     118p ==> 클래스 구조  
 *       => [접근 지정어] [제어어] class ClassName
 *              |    ----- 대부분은 default                       
 *              |    ----- static / 공통으로 사용되는 기능 => 네트워크(client/server), 데이터 분석 프로그램
 *              |          abstract / 추상클래스 (선언만 된 메소드) => 미완성된 클래스 (메모리 할당을 할 수 없다)
 *              |                     = 상속받은 후 구현 후 사용 (상속, 오버라이딩)
 *              |          final / 종단 클래스 => 확장을 할 수 없는 클래스 (사용빈도가 거의 없다) 
 *              |                 => String, System, Math, StringBuffer, Wrapper 
 *          -------- public
 *          -------- 한 개의 파일에 클래스를 여러 개 만드는 경우 public 은 한 번만 사용이 가능
 *          -------- 가급적이면 한 개의 자바 파일에 여러개 클래스는 만들지 않는다
 *       { 선택 사항
 *         --------------------------------------------
 *         변수 (멤버 변수)
 *           => 지정해서 관리할 데이터를 메모리에 저장할 목적 (프로그램 종료시까지 메모리 유지)
 *           => 따로 저장 하는 공간 -> 인스턴스 변수 => new 를 이용해서 메모리 공간을 만들고 저장후 사용
 *             -> 핵심
 *           => 1개만 저장 하는 공간 -> 정적 변수 => static
 *           => 변수로 사용할 수 있는것
 *             1) 기본형 (정수,실수,논리,문자)
 *             2) 배열 
 *             3) 클래스 -> 포함 클래스 -> 데이터 형(사용자 정의)
 *                ------ String
 *              
 *           => 변수는 외부에서(다른 클래스에서 변경할 수 없게 보호)
 *             = 캡슐화 : 변수는 은닉화 / 메소드를 통해서 접근이 가능
 *                      -------------------------------
 *                        | getter / setter (읽기/쓰기) => 기능 추가
 *             = 설정하는 변수는 private
 *             
 *             1) 출력 화면을 보고 데이터 추출****
 *                ------------------------- 안보이는 데이터 - 클래스의 변수 (찾기 => 구분자가 반드시 포함)
 *                  => 게시물 번호 / 영화 번호 / ...
 *                    배열의 인덱스와 매칭
 *             2) 캡슐화 => 시큐어 코딩의 기본
 *             ------------------------- lombok 이용하면 자동으로 getter /setter 만들어줌
 *         --------------------------------------------
 *         생성자 : 초기화 => 베열에 값을 체워준다 (파일 읽기, 오라클 연결)
 *             ** 클래스 블록은 선언만 가능
 *             ** 선언 
 *               => 변수 선언 -> int a;
 *               => 메소드 선언 -> public void display();
 *             초기화 블록에서 구현후 초기화
 *             ** 인스턴스 변수에 대한 초기화 => 생성자
 *                --------- 사용을 하기 위해서는 생성자가 반드시 호출
 *                --------- 클래스 객체 명 = new 생성자()
 *                                객체명.변수명
 *             ** 정적변수(static) 변수에 초기화 => static{}
 *                --------- 생성자 호출이 없어도 사용이 가능
 *                클래스 명.변수 명
 *                
 *                생성자
 *                -----
 *                  => 접근지정어는 public (다른 클래스에서 사용 가능)
 *                  => 클래스명과 동일
 *                  => 리턴형이 없다
 *                  => 여러 개를 만들 수 있다 : 같은 메소드 명으로 여러 개 생성해서 사용 => 오버로딩
 *                  => 모든 클래스에 한개 이상 존재
 *                    = 사용을 하지 않는 경우에는 생략이 가능 => 컴파일러가 생성자 1개 지원
 *                                                     ------------------
 *                                                      매개변수가 없는 생성자 (디폴트 생성자)
 *                                                      
 *         --------------------------------------------
 *         메소드 : 멤버변수를 활용하는 기능을 제작
 *                -----
 *                1) 목록 출력
 *                2) 상세 보기
 *                3) 예약(예매)
 *                4) 추천
 *                5) 결제
 *                6) 검색
 *            => 2개(결과값, 사용자 요청값)
 *                    |            |
 *                 return      매개 변수
 *             한 개만 사용    여러 개 사용이 가능
 *             				 (3개이상 초과 금지 권장)
 *           형식)
 *             [접근지정어][옵션 지정어] 리턴 형 메소드 명(매개 변수 리스트)    ==> 선언부
 *                |     ----- default(인스턴스 메소드) => 따로 저장
 *                |     ----- static ===> 공통으로 사용되는 기능 (한글변환, 암호화, 복호화, 정렬)
 *                |     ----- 7장 : abstract => 구현이 안되는 메소드 => 프로그램에 맞게 구현
 *                |           버튼 클릭 / 마우스 클릭 / 키보드 입력
 *                |           ------------------------------
 *                |              => 메소드는 호출이 가능하게 만든다..
 *                |              => 설계만 하는 기능 => 추상클래스 / 인터페이스
 *             --------       
 *              public : 자주 사용. 메소드는 다른 클래스와 연결할때 사용 => 공개
 *             {
 *               구현부
 *               return 전송할 값 
 *                **(void 일 경우 return 생략이 가능) 
 *             }
 *             
 *               => 메소드는 기능별로 나눠서 작업 => 구조적 프로그램
 *                  문장 => 단락을 나눠서 정리
 *                  반복적인 기능이 많은 경우
 *                  ----------------------------------------
 *                  다른 클래스와 연결
 *               => 재사용이 가능 => 수정 / 추가 ==> 클래스의 핵심
 *               => 메뉴 / 버튼 /입력창 / 마우스 클릭
 *                  ------------------------- 벤치마킹 (여러개) : 프로젝트의 핵심
 *                  ** 임펙트 = 핵심
 *                    영화 : 예매
 *                    맛집 : 추천 , 예약
 *                    여행 : 추천 , 코스 ..
 *                    쇼핑몰 : 결제 => 아이엠포트 (가상)
 *                          
 *                   (이력서의 포트폴리오가 없으면 학원에서 받아주지도 않음)
 *         --------------------------------------------
 *         ** 메서드는 호출 시마다 처음부터 시작
 *         public class A {
 *         	public void display() {
 *         	}
 *         	public int aaa() {
 *         	return 10;
 *         	}
 *         	public A[] bbb(int page) {
 *         				   ---- 여기의 매개 변수의 데이터 타입과
 *         	return new A[];
 *         	}
 *         }
 *         
 *         A aa = new A();
 *         aa.display() => void
 *         int a = aa.aaa();
 *         --- ================ 여기의 개매 변수 데이터 타입이 일치해야 함.
 *         A[] arr = aa.bbb(1)
 *       }
 *       
 *       
 *     122p ==> 객체 생성 방법
 *     	1. 클래스 :  설계
 *     		public class A {
 *     			int a;	
 *     			public void disp(){}
 *     		}
 *     	2. 메모리에 저장
 *     		A aa = new A();
 *     		  -- 메모리 주소 안에 ==> int a, disp()를 저장 ==> 접근할 때는 .을 사용
 *     	3. 객체 활용(변수 호출, 메서드 호출)
 *     		클래스 명 객체 명 = new 생성자()
 *     		객체 명. 변수 / 객체 명. 메서드()
 *     
 *     123p ==> 객체 사용 방법
 *     ------------------------------------------------------------------------------------
 *     	설계 ==> 저장 ==> 활용 ==> 메모리 해제
 *     	---		 ---	 ----	  ----------
 *     	class	 new	  .			null ==> 주소 값이 없는 상태(garbage collection 의 대상)
 *     ------------------------------------------------------------------------------------ 객체의 생명 주기
 *     
 *     127p ==> 접근지정어
 *     	=> 클래스와 클래스를 연결할 때 사용
 *     	=> 변수	=> private
 *     		[접근 지정어] 데이터 형 변수명
 *     		------------ private 로 설정한다 => 캡슐화 => 필요할 때 접근이 가능하게 만들려면 => getter / setter
 *     		변수는 기능이 2개.
 *     			1) 값을 저장하고	===> setter
 *     			2) 값을 가져온다	===> getter
 *     		private : 자신의 클래스에서 사용이 가능
 *     		------- 정보는 private 로 숨겨준다. (아이디, 비밀번호, 개인 정보 등)
 *     					public 을 사용하는 경우
 *     					===> JButton / JTextField / ... ==> 라이브러리 클래스
 *     	-----------------------------------------     
 *     	=> 클래스
 *     		[접근 지정어] class ClassName
 *     		------------ public
 *     	=> 메서드
 *     		[접근 지정어] [옵션 지정어] 리턴 형 메서드 명(매개 변수)
 *     		------------ public
 *     	=> 생성자
 *     		[접근 지정어] 클래스 명()	
 *     		----------- public
 *     
 *     	*** public 		=> 모든 클래스에 접근이 가능하다.
 *     	*** default		=> 자신의 클래스 / 같은 패키지 끼리만 접근이 가능하다.
 *     	*** protected	=> 자신의 클래스 / 같은 패키지 끼리만 접근이 가능하지만 ==> 상속 받은 경우에는 다른 패키지에서 접근이 가능.
 *     																			-----------------
 *     136p ==> 패키지
 *     			----- 관련된 클래스를 모아서 관리하기 하고 => 기능 별 분리 ===> 한 번만 사용이 가능하다.
 *     			package 경로 명
 *     				=> 패키지 명은 숫자로 시작할 수 없고 / 키워드를 사용할 수 없다.
 *     					=> com(org).회사 명.구분자
 *     										-----
 *     										오라클 연결	: dao
 *     										데이터 형 	: vo
 *     										크롤링 / OpenAi	: manager
 *     										웹 전송 	: service
 *     				=> 클래스 찾기가 쉽다.
 *     				=> 같은 클래스 명을 사용할 수 있다.
 *     				   -------------
 *     
 *     136p ==> import 사용 방법	==> package 를 불러오는 경우	==> 여러 개 사용이 가능하다.
 *     			------
 *     			1. 라이브러리를 불러오는 경우
 *     			2. 사용자 정의 클래스 불러오는 경우
 *     
 *     140p ==> 메소드
 *     152p ==> getter / setter
 *     166p ==> 생성자
 *     --------------------------
 *   6장
 *     194p ==> 상속 (웹에서는 거의 등장하지 않음)
 *     		상속 ==> 목적 / 형식
 *     		목적 : 기존의 클래스를 재사용할 때 사용 / 수정이 가능, 추가가 가능
 *     			   -------------------- 사용 중에 있기 때문에 => 신뢰성이 뛰어나다.
 *     			=> 상속 => 넘겨주는 내용
 *     				1. 변수 / 2. 메서드
 *     				-------
 *     				제외 :	static  => 공통으로 사용할 수 있게 만들어준다.
 *     						private => 상속은 된다(접근이 불가능 => protected 사용을 권장)
 *     				기타 제외 : 생성자, 초기화 블럭
 *     		형식 : class A extends B
 *     					--		  --
 *     					|		   |=> 상속을 내리는 클래스 : 라이브러리 상속을 주로 받는다.   								 
 *     					| 			   ------------------- 슈퍼 클래스, 부모 클래스, 상위 클래스, 베이스 클래스, 
 *     					|=> 서브 클래스, 자식 클래스, 하위 클래스, 파생 클래스
 *     						상속을 받아서 기존의 기능 + 추가 기능
 *     						---------------------------------- 확장을 해서 사용한다.
 *     				=> 상속을 내린 클래스의 소스를 반복할 필요가 없다.
 *     					=> 기능이 존재한다는 가정 => 소스가 간결하다.
 *     		class A {
 *     			기능 abc
 *     			void display(){}
 *     			----------------------- super.display();
 *     		}
 *     		class B extends A {
 *     			// 기능 abc가 있다고 가정. ==> (class A의 메모리가 저장된 상태)
 *     			// int a;	void display();		==> B.abc
 *     			   -----	-------------
 *     			  this.a	this.display()
 *     			int c;	
 *     		}				
 *     		*** 상속을 받은 클래스는 상속을 내린 클래스의 변수, 메서드에 접근이 가능하다.
 *     			상속을 내리는 클래스는 상속을 받은 클래스의 접근이 불가능하다.
 *     
 *     		*** 자바의 모든 클래스는 Object 클해스의 상속을 받는다.
 *     							   ------
 *     								Java 에서 가장큰 데이터 형
 *     							배열 => 같은 데이터 형만 모아서 사용할 수 있지만
 *     							Object[] arr = {" ", 10, 'A', 10.5}; 모든 데이터 형 사용이 가능하다.
 *     				
 *     201p ==> 단일 상속, 오버라이딩
 *     			=> Java 는 단일 상속만 가능
 *     			=> extends 클래스 명, 클래스 명 => 불가능
 *     			=> 두 개 이상을 받는 경우
 *     				class A
 *     				class B
 *     				class B extends A
 *     				class C extends B	==> 다중 상속을 하려면 상속을 여러 번 내려서 연결해주어야 함
 *     		==> 단점 => 다중 상속이 없어 불편한 점이 있다.
 *     					-- 인터체이스 (다중 상속)
 *     				=> 상속 받은 변수, 메서드가 보이지 않기 때문에 ==> 수정, 추가가 불편하다. (가독성이 떨어진다.)
 *     -------------------------------------------------------------------------------------------------------------
 *     	오라클 연결 (자바) => JDBC 			=> 2차 자바
 *     	JSP / MVC / Spring / Spring-Boot	=> 자바
 *     
 *     	HTML / CSS / JavaScript	====> 사용자 요청 처리 (자바)	======> 오라클 연결
 *     				 ----------										---------- 사이트에 필요한 데이터 저장소
 *     					  |
 *     				브라우저에서 실행		==>	자바는 브라우저에서 txt
 *     										오라클 연결이나 데이터 처리가 불가능하다.
 *     										화면 출력만 가능하다. 
 *     												| Full Stack |
 *     								퍼블리셔 == Front-End == Back-End
 *     								-------		--------	--------- Java, Oracle, Spring, Jsp
 *     								HTML, CSS	Vue.js
 *     											React	=> MVc는 괜찮지만 Redux / ReactCurry 가 난이도가 있음
 *     											Node.js
 *     											JavaScript library
 *     -------------------------------------------------------------------------------------------------------------		
 *     207p ==> 상속시 접근 제한 --> 캡슐화가 깨지는 경향
 *     			--------------
 *     				private (변수) => 상속을 내릴 때 반드시 getter / setter 을 사용해야 접근이 가능하다.
 *     211p ==> 상속시 생성자
 *     			default 생성자는 관계 없다.
 *     			매개 변수가 있는 생성자가 있는 경우에는 반드시 super()를 이용해서 상위 클래스의 생성자를 먼저 호출한다
 *     215p ==> 키워드(Super / this)
 *     				  -----	  -----
 *     					|		|=> 상속을 내릴 클래스의 변수 
 *     					|=> 상속을 내린 클래스의 변수, 메서드 호출,
 *     			-------------------------------------------------
 *     			this ==> 반드시 정리
 *     			---- 
 *     			=> 생성자, 멤버 메서드에서 사용이 가능
 *     			=> static 메서드에서는 사용이 불가능 => 멤버가 아니다(공통 ==> 1개의 메모리)
 *     				=> 사용이 필요한 경우에는 객체 생성 후에 사용한다
 *     		*** final 이 있는 경우
 *     			public final void display(){  ===> Overriding 이 불가능하다. (확장 불가능)
 *     				java.lang => final
 *     				--------- String, Math, Integer, Double, System, ...
 *     		} 	
 *     221p ==> 객체 형변환
 *     		1. 묵시적인 형 변환
 *     			double d = 10; 
 *     			int i = 'A';	=> 'A' == 65
 *     
 *      		==> 왼쪽이 큰 데이터 형이면 자동으로 데이터 형 변경
 *      		is - a 		has -s 
 *      		------		------		
 *      		 상속		포함

 *      	class A {}
 *      	class B => 객체 생성{}  ===> 비교가 불가능
 *      
 *       	class A{}
 *       	class B extends A ==> A가 > B보다 크다 ==> 상속을 내리는 클래스가 더 크다.
 *       	=> 객체 생성
 *       		
 *       		A a = new A();	==>  has - a
 *       		B b = new B();
 *       		A cc = new B();	==> 묵시적인 형 변환 A > B
 *       
 *       	=> 상속을 내린 클래스가 상속을 받은 클래스를 이용해서 메모리 할당이 가능하다.
 *       		
 *       		class 동물 {}
 *       		class 사랑 {}
 *       		class 사람 extends 동물
 *       
 *       		동물 a = new 동물()	==> is - a 관계 ==> 동물은 동물이다.
 *       		사람 b = new 사람()	==> 사람은 사람이다.
 *       		동물 c = new	 사람() 	==> 사람은 동물이다. 
 *       		사람 d = new 동물()	==> 동물은 사람이다.	===> is - a (X)
 *       		---------------------------------------
 *       		A a = new B();
 *       		B b = (B)a;
 *       		-------------- 객체 형 변환 (사용자 정의는 거의 없고 ===> 라이브러리에서 주로 사용
 *       																------------
 *       																|=> Object
 *       		class A {}
 *       		class B {
 *       			A a = new A();	=> 포함 has - a ==> A < B
 *       		}
 *       		=> 형 변환이 없다.
 *       		B b = new B();
 *       		b.a.display()	===> .이 2개 ===> System.out.println 과 같은 맥락.
 *       
 *       
 *      	2. 강제 형 변환
 *      		A a = new B();
 *      		B b = (B)a;
 *      		=> 리플렉션 Spring)
 *      	
 *      	==> 제어어
 *      		[접근 지정어] [제어어] 데이터 형 변수
 *      		---------------------
 *      			  |			|=> static : 공통적인 => 모든 객체가 동일하게 네서
 *      			  |			 => final : 마지막인 => 변수 : 상수 , 메서드, 클래스 : 종단
 *     				  |			
 *      			  |	
 *      			  |=> private, default, protected, public
 *      				  -------					   ------
 *      			     접근 거부						공개
 *      	
 *      	=> 클래스 구성
 *      		private : 변수 : 접근이 가능  setter / geter
 *      		생성자, 메서드  , => public
 *      
 *      	=> 상속
 *      		extends를 사용한다 => 모든 데이터 메서드가 넘어온다,
 *      		--------
 *      		=> 상위 클래스 제어 : super
 *      		=> 자신 클래스 제어 : this
 *      
 *      	=> 상속을 내리는 클래스는 자신 변수, 메서드, 상속 내린 클래스의 변수, 메서드 사용이 가능
 *      	
 *      	=>
 *      
 *      	class A {
 *      		int a = 10;
 *      		public void display();
 *      		{
 *      		}
 *      	}
 *      	
 *      	class B extends A {
 *      		int a = 100;
 *      		public void display(){};	
 *      	}
 *      		A aa = new A();
 *      			aa.a = 10 / aa.display() => A:display()
 *      		B bb = new B();
 *      			bb.a = 100 / bb.display(); => B:display
 *      		A cc = new B();
 *      		--		   --	// 상속이 있을 때만 사용이 가능하다.
 *      			cc.display() => B.display() => 메서드는 오버라이딩 메서드 호출이 된다.
 *      		cc.a = a = 10 (A가 가지고 있는 변수를 사용)
 *      
 *      	상속이 있는 경우에 => 변수는 선언된 클래스, 메서드는 생성자를 따라 간다
 *      	-------------------------------------------------------------------
 *      		클래스와 생성자가 다른 경우
 *      	------------------------------------------------------------------
 *      	다형성 : Overloading  / Overriding
 *      			-------------------------
 *      				  |				|=> 같은 메서드 명으로 기존의 기능을 수정 => 재정의
 *      				  |=> 같은 메서드 명으로 새로운 기능 추가 => 중복 메서드 정의
 *		------------------------------------------------------------------------------------------
 *										Overloading						Overriding
 *		------------------------------------------------------------------------------------------
 *			상태						같은 클래스 내에서					상속을 받은 경우
 *		------------------------------------------------------------------------------------------
 *			메서드 명						동일								동일
 *		------------------------------------------------------------------------------------------
 *			리턴 형						관계 없음							동일
 *		------------------------------------------------------------------------------------------
 *			매개 변수			개수, 데이터 형이 다르다						동일
 *		------------------------------------------------------------------------------------------
 *			접근 지정어					관계 없다						확장이 가능하다
 *		------------------------------------------------------------------------------------------
 *		객체 지향 (OOP)
 *			1. 데이터 보호 => 캡슐화 => private => 접근 금지. 사용 시에 메서드를 이용할 수 있게 한다.
 *															=> 읽기(getter) / 쓰기(setter)
 *			2. 재사용 => 변경해서 사용(상속), 있는 그대로 사용(포함)
 *			3. 수정, 추가가 쉽게.
 *			   ---	-----
 *				|	  |=> Overloading
 *				|=> Overriding
 *
 *   7장
 *     => 인터페이스
 *   8장
 *     => 예외처리
 *       = 직접 처리 -> try ~ catch
 *       = 간접 처리 -> throws Exception
 *   -----------------------------  자바 기본 형식(문법)    예상진도 다음주 7~8 장
 *   9장 ~ : 라이브러리 (필요한 메소드)                              마지막주 9 장
 *          Math => random() / ceil()
 *   -----------------------------------------------  
 *   
 *	
 */
class A {
		// default 생성자는 관련이 없다 -> 매개 변수가 있는 경우에  super
	
	public A(int a) {
		System.out.println(a);
	}
}
class B extends A{
	public B (int a) {
		super(a);	// 매개 변수가 있는 경우 반드시 super()를 호출한다
			//	상위 클래스 호출 => 메모리에 저장=> 하위 클래스 메모리를 저장
	}
	
}
public class MainClass_1 {
	
   public static void main(String[] args) {

   }

}