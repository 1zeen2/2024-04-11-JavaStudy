package com.sist.main;
/*
 * 	= 클래스의 종류
 * 		1) 추상 클래스
 * 			형식)
 * 				public abstract class ClassName {
 * 					   -------- 추상적인 (공통적인)
 * 
 * 				}
 * 				=> 공통으로 사용 되는 메서드를 선언만 한 상태이다.
 * 					=> 자신의 클래스를 매모리 할당 할 수 없다 => new 사용이 불가능하다.
 * 									  -------------------- 미완성된 클래스
 * 				=> 상속을 받아서 => Overriding 을 하고 사용한다.
 * 				=> 요구 사항(기능 설정) => 선언만 가능
 * 				=> 기능은 같지만 => 구현하는 내용이 다른 경우.
 * 					예) button 을 클릭 => 클릭한다는 기능은 같지만 후의 처리 내용이 다른 경우
 * 						=> 로그인 버튼, 로그아웃 버튼, 계산기 버튼, 회원 가입 버튼
 * 						=> 프로그램에 맞게 구현해서 사용...
 * 					예) 데이터 베이스 연결
 * 						-----------------
 * 						Oracle / MsSQL / MySql / Sqlite / MariaDB / DB2 / ...
 * 						-----------------------------------------------------
 * 						DriverManager
 * 						연결 시에 따로 클래스를 만들면 클래스가 바뀌어 전부 수정을 해야 함
 * 							=> 추상 클래스를 사용하면 하나로 통합이 가능하다.
 * 													-----------
 * 						=> 같은 기능끼리의 클래스를 모아서 한 개의 클래스 이름으로 관리할 때 주로 사용한다.
 * 					   ------------------------------------------------
 * 						데이터 => 배열
 * 						클래스 => 추상 클래스, 인터페이스
 * 							=> 서로 다른 클래스를 연결할 때 주로 사용
 * 							=> 클래스 마다의 공통 기능을 추출 ==> 선언을 한 상태에서 ==> 필요시마다 상속을 받아서 구현
 * 							   ----------------------------
 * 							=> 이미 기능이 선언되어있음. => 요구 사항(기능), 문제 풀이
 * 							=> 무조건 상속을 받아야 한다는 단점이 있다. ==> 단일 상속
 * 																		 --------- => 다중 상속이 가능하게 보완하는 중 ==> 인터페이스
 * 							=> 멤버 변수, 생성자도 가지고 있다.
 * 								=> 	1. 구현이 된 메서드
 * 									2. 구현이 안된 메서드가 0개 이상 있다. ==> 추상 메서드
 * 					예)
 * 						일반 게시판
 * 						----------
 * 							목록 출력	==> 게시물 출력
 * 							상세 보기
 * 							글쓰기
 * 							수정하기
 * 							삭제하기
 * 							검색
 * 
 * 						답변형 게시판
 * 						-----------
 * 							목록 출력	==> + 답변을 추가
 * 							상세 보기
 * 							글쓰기
 * 							수정하기
 * 							삭제하기		==> 답변을 먼저 삭제하고 나중에 게시물을 삭제해야 한다.
 * 							검색
 * 							+ 답변하기
 * 
 * 						갤러리 게시판
 * 						-----------
 * 							목록 출력	==> 이미지 출력
 * 							상세 보기	
 * 							글쓰기		==> + 이미지 업로드 기능
 * 							수정하기
 * 							삭제하기
 * 							검색
 * 
 * 						자료실
 * 						------
 * 							목록 출력	
 * 							상세 보기	==> + 다운로드
 * 							글쓰기		==> + 업로드
 * 							수정하기		==> + 파일 수정
 * 							삭제하기		==> + 파일 삭제
 * 							검색
 * 							파일 업로드
 * 							파일 다운로드
 * 
 * 						댓글형 게시판
 * 						------------
 * 							목록 출력	==> 댓글 개수 확인
 * 							상세 보기	==> 댓글 추가
 * 							글쓰기
 * 							수정하기
 * 							삭제하기
 * 							검색
 * 							댓글
 * 
 * 			=> 마우스 / 키보드
 * 			   -------------- 업체가 많다
 * 							  ---------- 운영 체제에 따라 마우스가 호환이 안될 수 있음 
 * 								=> 추상 클래스로 구현
 * 			=> [접근 지정어] abstract class ClassName {
 * 					-------------------------------
 * 					멤버 변수
 * 					-------------------------------
 * 					생성자 (생략 가능)
 * 					-------------------------------
 * 					메서드 {		=> 구현이 된 메서드
 * 					[접근 지정어] 리턴형 메서드(매개 변수...);
 * 						return 값;
 * 					}
 * 					-------------------------------
 * 					추상 메서드	=> 구현이 되지 않은 메서드
 * 					[접근 지정어] abstract 리턴형 메서드(매개 변수...)
 * 					=> 데이터 베이스
 * 					   ------------ 오라클 연동 / MySql 연동 ==> 같은 메서드를 구현
 * 						** 웹 ==> 데이터 베이스 연동	-----------------|
 * 								  J2EE => 웹 연결(브라우저)	 ---------| ==> 이 부분응 위해 Java 를 배움.
 * 								  ------------------------ 기본 문법이 지금 배우는 과정이 적용
 * 					-------------------------------
 * 				
 * 					-------------------------------
 * 
 * 
 * 		2) 인터페이스
 * 		3) 내부 클래스
 * 			=> Thread => 네트워크 (마지막 챕터)
 * 			=> 클래스 안에 클래스 설정 => 멤버 변수, 멤버 메서드를 쉽게 사용할 수 있게 만들어줌.	
 * 			class A {
 * 				변수, 메서드
 * 				class B {	==> 멤버 클래스
 * 					A가 가지고 있는 멤버 변수, 메서드를 메모리할당 하지 않고 사용한다.
 * 					=> A 객체를 생성할 필요가 없다.
 * 				}
 * 			}
 * 			class A {
 				===> 익명의 클래스 => 상속 없이 오버라이딩이 가능하다 => 윈도우 프로그램에서 많이 사용한다.
 * 				B b = new B() {
 * 					public void display(){}
				}
 * 			}
 * 			class B {
 * 				public void display(){}
 * 			}
 * 			*** 상속이 있어야 Overriding 가능 (X) ==> 익명의 클래스에서도 Overriding 가능하다.
 * 				스프링에서는 상속을 권장하지 않는다.
 * 							---- 상위 클래스에 맞게 사용해야 해서 제약이 많고 메모리가 커진다.
 * 																		   -------------- 상위 클래스 메모리 할당 후 => 하위 클래스 메모리를 할당하기 때문에.
 * 																							==> 처리 속도가 늦다.
 * 				=> 상위 클래스의 소스 코드를 모르는 상태에서 재정의하기 때문에 => 가독성이 떨어진다.
 * 
 * 		4) 종단 클래스 => 사용 빈도는 거의 없다 => 라이브러리에 존재하기 때문에 => 확장을 할 수 없다.(고정을 시켜주는 클래스)
 * 						  java.lang => String, System, Math, Wrapper, ...	=> 상속을 받을 수 없다.
 * 							=> public final class String
 * 									  ----- 상속을 할 수 없다(Overriding) 불가.
 * 
 * 
 */
 abstract class 도형 {
	 // 그리다. 그리눈 것은 같은데 안에 내용이다름.
	 	public abstract void draw();	// 메서드가 구현이 안됨 	==> 미완상된 클래스
	 									//					 	===> 메모리에 저장이 불가능
	 									// 여러 개의 관련된 것들을 모아서 관리하다,
 }
 class 선 extends 도형 {
	 		// 추상 클래스나 인터페이스 상속이 있는 경우에는 반드시 구현이 되지 않은 메서드를 구현해서 사용 ==> Overriding
	 /*
	  * 오버라이딩 => 재정의
	  * ---------
	  * 	1. 메서드 명 동일
	  * 	2. 매개 변수가 동일
	  * 	3. 리턴 형 동일
	  * 	4. 접근 지정어는 확장이 가능
	  * 	   ----------
	  * 		private	: 데이터 보호 목적 => 변수
	  * 		public	: 클래스, 메서드, 생성자 => 다른 클래스와 연결하기 위해
	  * 	5. 추상 클래스는 반드시 상속을 내려서 => 선언된 메서드를 구현해서 사용이 가능하다.
	  * 	   ---------- 자신은 메모리 할당이 불가능.
	  * 		is - a (이다)
	  */
	 @Override
	 public void draw() {
		 System.out.println("선을 그린다...");
	 }
 }
 class 사각형 extends 도형 {
	 @Override
	 public void draw() {
		 System.out.println("사각형을 그린다...");
	 }
 }
public class 추상클래스_1 {

	public static void main(String[] args) {
/*		선 a = new 선();
		a.draw();
		사각형 b = new 사각형();
		b.draw();
*/		
		// 클래스 변수 명 = new 클래스 명(); (생성자)
		도형 a = new 선();
		// 객체 . 추상 메서드 명();
		a.draw();
		
		a = new 사각형();
		a.draw();
		// 같은 종류의 클래스를 모아서 한 개의 객체 명으로 연결, 사용을 가능하게 만들어준다.
		// 기능 설정 => 프로그램에 맞게 구현

	}

}
