/*
 * 	객체 생성
 * 	--------
 * 	형식) new 생성자()
 * 			 ------	 클래스 명과 동일
 * 	예)
 * 		class A {
 * 	
 * 		}
 * 
 * 		A a = new A();
 * 		  - 객체 => 멤버 변수 / 멤버 메서드를 관리한다.
 * 
 * 		배열
 * 			int[] arr = new int[2]'
 * 
 * 			---- arr ----
 * 				0x100
 * 			------------	=>		arr[0]		arr[1]		=> 4byte씩 이동해야 해서 메모리 크기가 동일하고, 고정적으로 설정해야 하며, 같은 데이터 형만 사용이 가능하다.
 * 									------------------
 * 									  0			  0
 * 								   |------------------
 * 								0x100
 * 		클래스
 * 			class A {
 * 				String name;
 * 				int age;
 * 			}
 * 			A a new A();
 * 			----- a -----
 * 			-------------	=>	0x200--------------
 * 										---name---
 * 										   null
 * 										----------
 * 
 * 										---age----	=> a.age
 * 											0
 * 										---------
 * 
 * 			A a = new A();
 * 				  --- ----
 * 				   |	| 생성자 => 멤버 변수에 초기 값을 대입해주는 역할을 수행한다. => 같이 다닌다.
 * 				   | 클래스에 있는 멤버 변수를 저장할 수 있는 공간을 만들어준다.
 * 					 a라는 공간에 저장된 메모리 주소를 넘겨주는 역할.
 * 					** 생성자 호출 시에는 반드시 new 생성자();
 * 											   ------------
 * 				저장되어 있는 변수나 메서드를 관리 하는 것 => 객체 => 설계 (클래스)
 * 
 * 				1. 설계 => class
 * 				2. 메모리 저장 => new
 * 				3. 활용 => new 로부터 받은 메모리를 이용해서 활용 => 객체
 * 				------------------------------------------------------ 객체 지향 프로그램
 * 				주 목적 : 재사용, 수정 - 추가를 편리하게 만든다
 * 
 * 				=> 객체 사용
 * 					1. 생성
 * 						A a = new A();
 * 						--------------
 * 						A a;
 * 						a = new A();
 * 						--------------
 * 					2. 사용시에는 
 * 						a.변수
 * 						a.메서드
 * 						--------------	.은 메모리 주소 접근 연산자
 * 										-------------------------
 * 					=> 참조 변수 (객체) => 메모리 주소를 이용하는 방식
 * 					=> 일반 변수 => 메모리에 저장된 값을 이용하는 방식 
 * 					
 * 					int a = 10;
 * 					int b = a;	==> a의 값을 변경하거나 b의 값을 변경하더라도 다른 변수에 영향을 미치지 않는다. (메모리의 값만 가지고 오는 방식)
 * 
 * 		class A {
 * 			String name;
 * 			int age;
 * 		}
 * 		A a = new A();
 * 			(0x100)
 * 		주소를 가지고 있는 공간 => Stack	 // 실제 데이터 값이 저장되는 곳 (Heap)	
 * 
 * 		A b = a;	=>	a.name / b.name 두 개가 동일하다. a.age / b.age
 * 		(0x100)
 * 	
 * 
 */
class A {
	String name;
	int age;
}
public class 클래스_9 {

	public static void main(String[] args) {
		A a = new A();
		System.out.println("a = " + a);
		
		a.name = "박문수";
		a.age = 30;
		
		System.out.println("a.name = " + a.name);
		System.out.println("a.age = " + a.age);
		System.out.println();
		// 메모리 주소를 받는 경우 ==> 메모리에 있는 변수 자체를 제어할 수 있다 => a의 별칭을 만든다는 개념 => 동시에 같은 메모리 변수를 사용이 가능하다.
		
		A b = a;
		System.out.println("b = " + b);
		
		b.name = "이순신";
		b.age = 25;
		
		System.out.println(b.name);
		System.out.println(b.age);
		
		System.out.println();
		
		System.out.println("a.name = " + a.name);
		System.out.println("a.age = " + a.age);
		
		// 배열, 클래스는 메모리 주소를 이용하는 방식이다 => 대입하면 같은 메모리를 제어한다(얕은 복사) => 참조 변수 
	}

}
