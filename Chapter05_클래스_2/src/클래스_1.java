/*
 * 프로그램
 * 
 * 	요구 사항 분석 ===> 데이터베이스 설계 ===> 화면  UI 만들고 ====> 구현 ======> 테스트 ====> 배포
 * 	1) 필요한 데이터		데이터 값을 저장								|					 	 |
 * 	2) 기능 설정													웹 프로그래머			   발표
 * 	------------ 클래스 (설계)
 * 	=> 프로그램에 필요한 데이터 => 변수
 * 	=> 기능 설정				  => 메서드
 * ------------------------------------
 * 	변수의 집합 + 메서드
 * 		|
 * 	 초기 값 => 생성자
 * ----------------------------------- 관리 => 관리의 영역 영역 (객체) => 메모리에 저장 후 사용
 * 																		-------------------- 객체
 * 
 * 	현실 세계에 있는 모든 사물 => 단순화
 * 	예 )
 * 		사원 => 시뮬레이션 (가정)
 * 		=> 프로그래머가 알 수 있게 설계
 * 		사번 / 이름 / 부서명 / 직위 / 등등...의 변수 ==> 한 명에 대한 설계
 * 		출근한다 / 퇴근한다 / 점심을 먹는다 ... 메서드
 * 
 * 	1) 객체 지향 프로그램
 * 		1. 변수 설정 => 어떤 데이터를 관리할지
 * 		2. 기능 설정 => 메뉴
 * 	
 * 	2) 설계
 * 		---------------------- 설계 => 한 개에 대해서만 설계 => new를 이용해서 여러 개를 저장
 * 		class ClassName {			(맛집 1개, 학생 1명, 영화 1개)
 * 
 * 		}
 * 		---------------------- 메모리에 저장 후 => 관리
 * 	3) 클래스의 구성 요소
 * 		class ClassName {
 * 		------------------
 * 		변수 묶음
 * 			1. 변수의 종류
 * 			= 객체 변수 => new를 이용해서 저장 시 마다 메모리가 달라진다 (저장 공간이 따로 생긴다) => 여러 개를 저장할 수 있음
 * 				=> 인스턴스 변수 (메모리에 저장 된 상태) => (객체 == 인스턴스)
 * 			= 공통 변수 => 모든 객체가 동일한 변수를 사용
 * 				=> static => 메모리 공간을 한 개만 생성함 => 공통으로 사용이 가능하다
 * 
 * 			2. 데이터를 보호 : 다른 프로그램에서 사용이 안되게 만든다 => 감춘다(은닉화)
 * 			   ------------ 자체 프로그램에서는 사용이 가능(캡슐화)
 * 			   ------------ 접근 지정어.
 * 		------------------
 * 		초기화 (변수)
 * 			1. 명시적인 초기화 (다이렉트로 값을 집어넣음)
 * 				int a = 10; => 특별한 경우가 아니면 사용 빈도가 낮다
 * 
 * 			2. 초기화 블럭
 * 				= 인스턴스 블럭
 * 					class ClassName {
 * 						변수
 * 						{
 * 							인스턴스 블럭 ==> 구현 => 웹에서 주로 사용
 * 													=> 자동 로그인, 쿠키 읽기, 세션 등록, 데이터 베이스 연동, ....
 * 													=> 윈도우에서 화면 UI 만들기.
 * 													=> 인스턴스, static 변수 초기화가 가능하다
 * 						}
 * 					}
 * 						*** 클래스 영역
 * 					class ClassName {
 * 						구현은 불가능. 선언만 가능한 영역.
 * 						------------ 연산자 / 라이브러리 메서드 호출, 파일 읽기, 데이터베이스 연동, 제어문 => 구현
 * 									 {} 안에서 사용이 가능.
 * 					}
 * 				= 정적 블럭(static)
 * 					class ClassName {
 * 						static 변수 =>
 * 						static {
 * 							static 변수만 초기화가 가능하다 => new를 이용하지 않고 자동으로 저장이 되게 만든다.
 * 							------------ 단점 : 저장된 모든 객체가 공통으로 사용하는 변수
 * 						}
 * 					}
 * 					= 보통 사용하는 초기화
 * 						=> 생성자 => 메모리에 저장 시에 반드시 호출
 * 									------_
 * 									| new Scanner()
 * 									   |  --------- 생성자 => 클래스 명과 동일하다
 * 									   |	|생성자는 변수의 초기화 => 값을 저장한다.
 * 									연산자
 * 									1. 클래스 메모리의 크기를 확인
 * 									2. 메모리에 저장 => 메모리 확보와 => 메모리 주소를 객체에 전송한다.
 * 						에)
 * 							class A {
 * 								int aa; => 0으로 초기화 => 클래스 영역에서는 자동으로 초기화가 된다.
 * 								int bb; => 0으로 초기화
 * 							}
 * 						
 * 							int[] arr = {1, 2};
 * 							
 * 							-- arr --
 * 										0x100의 첫 번재 값 0x100의 두 번째 값
 * 												arr[0]		arr[1]	=> 인덱스를 이용하는 방법 => 메모리 크기가 동일해야 한다.
 * 							---------		 --------------------------
 * 											 	1		|		2
 * 											|--------------------------
 * 										0x100
 * 								** 데이터를 설계하는 과정에서 => 메모리의 크기가 다른 것이 있어서 => class 사용
 * 
 * 								1. 클래스 저장
 * 									A a = new A();
 * 										  ---
 * 										   |		
 * 									   --- a ---
 * 									     0x100			0x100
 * 								    	---------	=>		--------------------
 * 															---------------- aa
 * 																	0
 * 															--------------------
 * 															---------------- bb
 * 																	0	==> 초기 값을 지정해주는 역할 => 생성자
 * 															-----------------
 * 									A b = new A() => new를 따라 메모리가 생성이 된다 => 접근하는 해당 범위는 해당 주소에서만 사용이 가능하다
 * 										  ---
 * 										   |
 * 								      ---- b ----
 * 										0x200			0x200
 * 										-----		=>		--------------------
 * 															---------------- aa
 * 																	0
 * 															--------------------
 * 															---------------- bb
 * 																	0	==> 
 * 															-----------------
 * 									=> new는 사용할 때 마다 따로 메모리를 생성한다 (클래스의 크기만큼) => 하드디스크 크기만큼 사용이 가능하다.
 * 									=> new를 이용해서 저장되는 내용
 * 										1. 변수, 2. 메서드 ==> 관리하는 역할 ==> 객체
 * 																			   ----
 * 																	사용자 정의 데이터 형에 대한 변수
 * 		------------------
 * 		기능 설정 => 메서드 (웹에서는 동작하는 기능)
 * 							키보드 입력 (검색, 회원 가입, 글 쓰기, ...)
 * 							마우스 클릭 (상세 보기, ....)
 * 							메뉴	 클릭 => 메서드 (동작)
 * 
 * 				 => 메서드의 종류
 * 					1) 일반 메서드 (인스턴스 메서드 / 객체 메서드) => 객체마다 따로 저장되는 메서드
 * 						[접근 지정어] 리턴형 메서드 명(매개 변수, .....) {
 * 							=> 기능 처리할 때 사용하는 형식
 * 						}
 * 
 * 					2) 공통 메서드 : 객체가 동일하게 사용하는 메서드
 * 						[접근 지정어] [옵션 지정어] 리턴 형 메서드 명(매개 변수, ....) {
 * 							=> 한글 변환 (많이 어려움), 데이터 베이스 연동, ...
 * 							=> MySQL / MariaDB
 * 							   --------------- 3차  project
 * 						}
 * 					3) 종단 메서드 : 수정이 불가능한 메서드
 * 						[접근 지정어] final 리턴 형 메서드 명(매개 변수...)
 * 						=> String / System / Math... => 변경이 불가하고, 있는 그대로 사용해야 한다
 * 
 * 					4) 추상 메서드 : 선언만 되어 있고, 구현이 되어있지 않다. => 프로그램에 맞게 구현해서 사용해야 한다
 * 						=> 윈도우
 * 							버튼 클릭 / 마우스 클릭 / 키보드 입력 / ...
 * 								| 클릭 => 프로그램마다 처리하는 내용이 다르다.
 * 									=> 로그인 버튼, 계산기 버튼, 검색 ..., 취소... => 호출은 가능하다.
 * 						=> 인터페이스
 * 						   --------- 다른 클래스를 연결 시에 주로 사용한다.
 * 							스프링 <=> 오라클
 * 							스프링 <=> JavaScript 연동
 * 							----- 인터페이스 기반
 * 		------------------------- => 한 개의 메모리에 저장한 후에 관리하는 역할 => 객체 (변수)
 * 									=> 클래스를 저장하는 변수
 * 		}
 */
// 클래스에 선언되는 변수
/*
 * Card 설계
 * => number / type(image) => 각 카드의 수가 다르고 값을 따로 가지고 있음 => 인스턴스 변수.
 * => width / height => 모든 카드가 동일하다. => static
 */
class Card {
	// 각자 사용되는 변수 (생성할 때 마다 사용되는 변수) => 인스턴스 변수
	// 공통으로 사용되는 변수 => 정적 변수 (static)
	int number;		// 0으로 초기화
	
	
	String type;	// null 값으로 초기화
	// 필기체 : 공통으로 사용 되는 변수 ==> 정적 변수 ==> static
	// 아직 저장이 되지 않음. ===> new를 사용해야 저장된다.
	
	static int width = 200, height = 300; // 명시적 초기화 ==> 저장 ==> static은 컴파일 시 저장된다.
	// 볼드체 : 지역 변수, 매개 변수 (밤색)
	// 프로그램 종료 시 까지 메모리가 유지된다 => Heap(프로그래머가 담당하는 메모리 영역)
	
	/*
	 * 	------------------------------------------------------------------------------------------------------------------------
	 * 		종류			메모리 저장 시점			메모리에서 해제			저장 위치			사용 범위
	 * 	------------------------------------------------------------------------------------------------------------------------
	 * 	지역 변수		메서드 호출				메서드가 종료			Stack				메서드 안에서만 사용이 가능하다.
	 * 					=> 메모리에 저장			return 에서 해제
	 * 	------------------------------------------------------------------------------------------------------------------------
	 * 	인스턴스 변수	new 를 이용할 경우		프로그램 종료 시 까지		Heap				클래스 전체에서 사용이 가능하다.
	 * 																						=> 다른 클래스에서도 사용이 가능하다.
	 * 	class A {
	 * 		int aa;
	 * 	}
	 * 	A a = new A(); ==> 
	 * 		a는 변수 / 메서드를 관리하는 공간 => 객체
	 * 		------ a ------
	 * 			 --aa--
	 * 			-------
	 * 		--------------- => a.aa (.은 메모리 주소 접근 연산자) ===> a 주소 안에 저장되어 있는 aa 라는 변수에 접근한다.
	 * 	------------------------------------------------------------------------------------------------------------------------
	 * 	정적 변수		컴파일 시 저장			프로그램 종료 시 	까지		Method Area 		클래스 전체에서 사용이 가능하다.
	 * 	static																				=> 다른 클래스에서도 사용이 가능하다.
	 * 	------------------------------------------------------------------------------------------------------------------------
	 * 
	 * 	class A {
	 * 		static int a; => new 없이 저장이 가능 => 모든 클래스에서 공통으로 사용되는 변수
	 * 	}
	 * 
	 * 	A aa = new A();
	 * 	aa.a => 객체를 통해서 접근이 가능
	 * 	A.a => 클래스 명으로 접근이 가능
	 * 		
	 * 
	 */
}
public class 클래스_1 {

	public static void main(String[] args) {
		// 카드 1장 저장
		Card card1 = new Card();
		System.out.println("card1 = " + card1);	// Card@1eb44e46
		
		//변수의 초기화
		card1.number = 3;
		card1.type = "♠";
		System.out.println("number = " + card1.number);
		System.out.println("type = " + card1.type);
		System.out.println("width = " + card1.width);
		System.out.println("height = " + card1.height);
		System.out.println("=========================");
		/*
		 * 		static => 별도의 영역에 따로 1개만 저장이 된다 => card1, card2 모두 접근이 가능하다.
		 * 		------card1-------
		 * 		저장된 메모리 주소
		 * 		card1 = Card@1eb44e46
		 * 		------------------		 Card@1eb44e46	--------------------
		 * 													----------
		 * 														3 => number	=> card1.number
		 * 													----------
		 *
		 * 													----------
		 *														♠ => type	=> card1.type
		 *													----------
		 * 												--------------------
		 */
		Card card2 = new Card();
		card2.number = 5;
		card2.type = "♣";
		System.out.println("card2 = " + card2);	// Card@e73f9ac
		System.out.println("number = " + card2.number);
		System.out.println("type = " + card2.type);
		
		System.out.println();
		
		System.out.println("width = " + card2.width);
		System.out.println("height = " + card2.height);
		
		System.out.println();
		
		/*
		 * 		------card1-------
		 * 		저장된 메모리 주소
		 * 		card1 = Card@e73f9ac
		 * 		------------------		 Card@e73f9ac	--------------------
		 * 													----------
		 * 														3 => number	=> card2.number
		 * 													----------
		 *
		 * 													----------
		 *														♠ => type	=> card2.type
		 *													----------
		 * 												--------------------
		 */
		// static 으로변경.
		// 같은 메모리 공간을 제어 => 해당 되는 모든 값이 변경된다.
		card1.width = 300;
		card1.height = 500;
		
		card2.width = 500;
		card2.height = 1000;
		
		Card.width = 1200;
		Card.height = 1500;
		
		System.out.println("card1.width = " + card1.width);
		System.out.println("card1.height = " + card1.height);
		
		System.out.println();
		
		System.out.println("card2.width = " + card2.width);
		System.out.println("card2.height = " + card2.height);
		
		// 인스턴스 변수 => 메모리가 따로 생성된다 => 각각의 영역만 제어가 가능하다
		card1.number = 7;
		card1.type = "♥";
		
		card2.number = 8;
		card2.type = "◆";
		
		System.out.println("card1.number = " + card1.number);
		System.out.println("card1.type = " + card1.type);

		System.out.println();
		
		System.out.println("card2.number = " + card2.number);
		System.out.println("card2.type = " + card2.type);
		
		/*
		 * 	프로그램에서 데이터 관리 => React / Vue => 데이터 관리
		 * 	----------------------
		 * 	변수 => 배열 => 클래스	  연산자 / 제어문 => 변경 사항이 없다. 
		 * 	=> 파일 => 오라클
		 * 
		 *	공통 저장 / 따로 저장 
		 *	 | static	| 변수 선언
		 *	 | 정적 변수	| 인스턴스 변수 => 메모리가 별도로 생성된다. (new)
		 *	 |=> 컴파일시 생성이 된다.
		 */ 
	}
		

}
