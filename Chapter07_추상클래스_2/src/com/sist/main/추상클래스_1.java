package com.sist.main;
/*
 *	일반 클래스
 *		= 구성 요소
 *			class ClassName {
 *				---------------------------------------------
 *				변수
 *					=> 따로 저장하는 변수 : 인스턴스 ==> 새로운 메모리 공간을 만들어서 저장
 *													   ----------------- new
 *					=> 한 개를 가지고 사용하는 변수 : static
 *				---------------------------------------------
 *				생성자 : 변수에 대한 초기화
 *						윈도우 / 웹 / 데이터베이스 : 시작과 동시에 처리
 *						화면 UI / 자동 로그인, 쿠키 / 드라이버 등록
 *
 *				=> 반드시 필요하다 : 메모리 저장시에 호출
 *				   -------------- 없는 경우에는 컴파일러에 의해 자동으로 추가되기 때문에 ==> 필요 없는 경우에는 생략이 가능하다.
 *
 *				=> 여러 개를 만들 수 있다.
 *					=> 디폴트 생성자 : 매개 변수가 없는 생성자
 *					=> 매개 변수가 있는 생성자 => 사용자로부터 초기 값을 받아서 저장
 *					=> 클래스 내에서 생성자를 호출 할 때는 this() 를 이용한다.
 *														------- 생성자 내에서만 호출이 가능하다.
 *																한 번만 호출이 가능하며
 *																반드시 첫 줄에 사용되어야 한다.
 *
 *														super() 는 상속을 받는 경우에 사용한다.
 *
 *					=> 자동 처리 => 컴파일러에 처리
 *						1. 모든 클래스는 Object 상속을 받는다 => Object 상속을 생략할 수 있다.
 *							public class A extends Object
 *										   -------------- Object 에서 제공하는 모든 기능 사용이 가능
 *															=> 객체 비교	: equals()
 *															=> 소멸자	: finalize()
 *															=> 복제		: clone()
 *															=> 주소 출력	: toString()
 *
 *						2. import 가 생략
 *						   import java.lang.*;
 *								  ----------- String, Math, System, ...
 *
 *						3. Method
 *							void => return 을 생략하면 => 자동으로 추가
 *
 *						4. 상속
 *							class A {}
 *
 *							class B extends A {
 *								public B() {
 *									super()
 *									------ 	생략
 *									------ 	생략할 수 없는 내용										
 *											------------------ 상속을 내리는 클래스의 생성자가 매개 변수를 가지고 있는 경우에는 생략할 수 없다.
 *								}
 *							}
 *							==> super() (상위 클래스의 메모리 할당) => 자신의 메모리 할당
 *								---------------------------
 *								   ------- super -------
 *									상속 받은 변수 / 메서드
 *								   ---------------------
 *						
 *									------- this -------
 *									추가된 변수 / 메서드
 *								   ---------------------
 *								---------------------------	this, super 에 있는 변수, 메서드 사용이 가능하다.
 *						5. 예외 처리가 생략 => Java 의 모든 클래스는 예외 처리를 가지고 있다
 *						   --------
 *							   | 에러 방지 => 에러(소스 상에서 수정할 수 없는 에러) / 예외 처리(소스 상에서 수정이 가능한 에러)
 *											  메모리 할당할 공간이 없습니다.		/ 정수 => 문자열
 *								-----------------------------------------------------------------------------------------
 *									
 *							컴파일 시 처리, 실행시(생략이 가능)
 *							------------   ------
 *								javac		java
 *								  | 파일 입출력, 네트워크, 쓰레드, 데이터베이스, 웹, ...
 *								  |	Spring(웹)
 *							---------------------------------------------------------------------------------------------
 *							=> 기능 처리 (사용자 요청 처리) => 메서드
 *								=> 기능 요청은 한 개만 요청이 가능하게 만든다.
 *								=> 메서드는 반드시 한 개의 요청에 대한 처리만 한다.
 *									예) 에러 빈번하게
 *										-----------
 *										1) 사용자 입력 (요청 값 오류)		===> if 로 제어가 가능
 *										2) 프로그래머의 실수 (*******) 	===> 에러를 잡기가 굉장히 어렵다.
 *										------------------------------------------------------------------
 *										NullPointException / ClassCastExceotion / ArrayIndexOutOfBoundsException
 *										------------------------------------------------------------------------ 가장 흔하게 보이는 3대 에러
 *												| 윈도우 에러 / | 객체 형변환 에러 / | 배열 범위 초과 에러
 *
 *							메서드 : 구현을 반드시 해야 한다
 *										선언부 {
 *										} // 블럭이 닫히면 메모리 저장. 
 *										
 *			
 *								
 *		
 *							
 *
 *	추상 클래스 : 사용자 정의는 거의 없다 => 추상 클래스의 확장된 개념 ==> (인터페이스)
 *					=> 라이브러리에 추상 클래스가 많이 존재
 *					   ---------- 상속 => Overriding 하는 이유
 *								  --------------------------- 메모리 할당을 할 수 없다 ==> 미완성 클래스라고 하며 ==> 메서드 구현이 안 된 경우.
 *																												   ----------------------- 설계만 하고 상속을 받아 사용
 *																																			익명의 클래스를 이용한다.
 *				[접근 지정어] abstract class ClassName {
 *					----------------------------------
 *					변수는 일반 클래스와 동일
 *					----------------------------------
 *					생성자
 *					----------------------------------
 *					구현 된 메서드 : 상속받은 클래스가 동일한 기능을 수행한다.
 *					----------------------------------
 *					구현이 안된 메서드 : 상속받은 클래스마다 기능은 동일한데 구현이 다른 경우 => 선언
 *					---------------- 추상 메서드
 *					[접근 지정어] abstract 리턴 형 메서드 명(매개변수, ...)
 *						=> 프로그램에 맞게 구현하여 사용한다
 *
 *				=> 주로 사용되는 곳은 클래스마다 기능은 동일한데 => 구현 내용이 다른 경우 => 선언을 통하여 => 유지보수가 편리하게 만들어준다.
 *				=> 사이트마다 약간씩 다르다
 *					---------------------
 *					로그인, 로그아웃, 회원가입, ...
 *					=> 네이버	: Ajax
 *					=> 네이트	: 일반 jSP
 *					=> 아시아나 항공 : NueJs
 *					-----------------------
 *					벤치 마킹에 따라 다름 => 기능 / 설계 => 추상 클래스
 *				
 *					=> 상속이 안되는 소스
 *						---------------
 *						1. 생성자, static, 초기화 블ㄹ
 *
 *	
 *
 *	
 *
 */
class A {
	// public A(){} 가 생략되어있다.
}

class B extends A {
	
	public B() {
		// super() 는 생략이 가능하다.
	}
}

class C {	// extends Object 가 생략되어 있음. 
	public C (int a) {
		
	}
}
// class D ==> 하위 클래스
// class C ==> 상위 클래스
// 상속을 받아 새로운 확장된 클래스를 만들어서 사용한다.
class D extends C { // class D는 class C와 생략된 class Object 모두 상속받는다.
	public D() {
		super(10);	// 매개 변수가 있는 상위 클래스를 상속 받는 경우에는 반드시 super 를 이용해서 호출해야 사용이 가능하다.
		// 사용자 정의는 거의 없다.
		// super(), this() => 생성자 내에서 호출이 가능하다, 반드시 첫 줄에 호출해야 한다.
		// 												   -------------------------- 때문에 동시에 super(), this()는 함께 사용이 불가능하다. ==> 둘 중 하나는 두 번째 줄로 가기 때문에.
		// 상위 클래스 제어 => super, 생성자 super()
		// 자신 클래스 제어 => this, 생성자 this()
	}
}
abstract class AAA {
	public abstract void display();
}

public class 추상클래스_1 {

	public static void main(String[] args) {
		
	}

}
