/*
 * 메서드 : 기능 처리(사용자 요청 처리) => 한 개의 기능만 수행이 가능하게 만드는 명령문의 집합
 * 		명령문
 * 			1. 변수 선언
 * 			2. 연산 처리
 * 			3. 제어문 처리
 * 		1) 메서드 구조
 * 			[접근지정어] [옵션](지정자) 리턴형 메서드명(매개 변수 목록) => 선언부 (원형) {
 * 				구현 ....
 * 				return 값;
 * 					=> 리턴은 중간에 올 수도 있다.
 * 					=> 생략은 불가능하며 void를 사용하는 경우에만 생략이 가능하다 (컴파일러에 의해 자동으로 return이 첨부되기는 한다)
 * 			}
 * 			
 * 			접근 지정어 : 다른 클래스에서 접근하는 범위
 * 			--------- public / protected / private / default => 같은 폴더에서만 접근이 가능
 * 
 * 			옵션	:
 * 				1) default	: 없는 경우
 * 				2) static	: 자동 메모리 할당 => 공유
 * 				3) abstract	: 추상 메서드 => 선언 => 프로그램에 맞게 구현해서 사용
 * 				   -------- 버튼 클릭 했을 때 많이 사용한다
 * 				4) final	: 종단 메서드 => 수정이 안 되는 메서드
 * 			리턴형 : 사용자 요청에 대한 결과 값
 * 					=> 반드시 한 개만 사용해야 함, 여러 개 일 때는 배열을 이용하거나 클래스를 이용하는 방식이 있음
 * 					   -------------------- 기본형 데이터 타입을 사옹해야 함.
 * 			메서드 명 : 변수 식별자와 동일
 * 			매개 변수 : 여러 개 사용이 가능하다 => 사용자가 보내주는 값
 * 			메서드 호출 : 메서드 호출 시에는 처음부터 끝까지 사용한다. 사용이 끝나면 호출한 위치로 돌아가 다시 코드 내용을 수행함.
 * 
 * 		void display {
 * 			1 2 3 ...
 * 		}
 * 
 * 		main() {
 * 			1 2 3 4... => 1
 * 			5 6 7 8... => 2
 * 			display..  => 3
 * 				=> display 메서드의 123.. 을 수행
 * 			9 10 11... => 4 의 순서로 진행.
 * 		}
 * 
 * 	=>	반복적인 문장이 있는 경우 (코드 반복을 제거할 수 있다)
 * 		구조적인 프로그램 -> 단락에서 수정, 오류 처리가 용이하다
 * 		재사용에 용이하다. main클래스는 다른 클래스에서 호출이 불가능하다.
 * 			=> 재사용의 의미는 코드를 붙여넣는 것이 아닌 메서드나 클래스를 호출해서 사용하는 것을 재사용이라고 함.
 * 		객체 지향 프로그램 => 클래스와 클래스의 상호 연결이 가능한 것
 * 		클래스 / 기능 / 조립
 * 				|	  | 메인보드 (main이 있는 클래스)
 * 				|
 * 				CPU, 메모리, 하드디스크, 사운드, 등등.. 
 * 			-------------
 * 			=> System.out.println() / random() 등이 지원하는 메서드에 해당된다.
 * 	
 * 		예) 사용자가 로그인을 요청하는 경우
 * 				id, pwd => 매개 변수
 * 				결과 값 => boolean
 * 
 * 			사용자가 아이디 중복 체크를 요청하는 경우
 * 				id => 매개 변수
 * 				결과 값 => boolean
 * 
 * 		웹 => 매개 변수 (이미지 클릭, 페이지 번호 클릭, 입력 (검색어)
 * 			=> 화면 이동 => return
 * 			=> 출력할 내용이 많은 경우 => 배열 / 컬렉션 이용.
 * 		--------------------------------------------------
 * 		매개 변수 전송 법
 * 		1. 값 전송	==> 메모리를 따로 만들어서 처리하는 과정
 * 			Call By Value
 * 			기본형 => 원본은 그대로 유지한다.
 * 
 * 		2. 주소 전송	==> 메모리가 같은 곳에서 전송
 * 			배열 / 클래스 => 원본이 변경된다.
 * 			Call by Reference
 * 			예외) => String은 일반 기본형과 동일하다
 * 
 */
public class 메서드정리_1 {
	// Call By Value => 실제 값만 전송. (다른 메모리를 새로 생성하여 원형의 값이 변경되지 않는다.)
	// Call By Reference => 메모리 주소를 전송. (메모리 주소가 넘어가기 때문에 값이 변경된다.)
	static void rand (int[] arr) {
		System.out.println("arr = " + arr);	// 주소가 같은 경우에는 같은 메모리를 제어한다.
		for (int i = 0; i < arr.length; i++) {
			arr[i] = (int)(Math.random() * 100) + 1;
		}
	}
	/*
	 * 얕은 복사
	 * int[] arr = new int[5];
	 * 
	 */
	public static void main(String[] args) {
		int[] nums = new int[5]; // 주소가 동일하기 때문에 return값이 필요가 없다 => 값 자체가 변경되기 때문
		System.out.println("nums = " + nums);
		rand(nums);
		
		for (int i : nums) {
			System.out.print(i + " ");
		}
	}
}
