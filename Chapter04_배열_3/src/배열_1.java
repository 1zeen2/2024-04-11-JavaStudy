
/*
 * 	배열 : 같은 데이터형 여러개 데이터를 모아서 저장
 * 		   ----------- 용도가 같은 데이터
 * 		   => 고정적 단점
 * 		   => 여러개의 데이터를 한 개의 이름으로 제어할 수 있다는 장점이 있다.
 * 							   ------------------- 인덱스를 이용하여 접근이 가능하며 0번부터 시작이 된다.
 * 			1) 선언하는 방식
 * 				데이터형[] 배열명;
 * 				데이터형 배열명[];
 * 				int[] arr;		=> 정수형
 * 				double[] arr;	=> 실수형
 * 				char[] arr;		=> 문자형
 * 				String[] arr;	=> 문자열형
 * 				boolean[] arr;	=> 논리형
 * 
 * 			2) 초기화 하는 방법
 * 				=> 실제 값을 초기화 하는 방법
 * 				=> 기본 값을 초기화 하는 방법
 * 				int[] arr;
 * 				arr = new int[]{1, 2, 3, 4, 5};
 * 				=> 기본 값을 초기화.
 * 				
 * 				int[] arr = new int[5]; 		====> 자동으로 0(기본값)으로 초기화	===> 가장 많이 사용
 * 
 * 				int[]		= 0
 * 				double[]	= 0.0
 * 				boolean[]	= false
 * 				string[]	= null (주소가 없는 상태)
 * 								=> 모든 클래스에 저장(참조할 수 있는 주소)
 * 				long[]		=> 0L
 * 				char[]		=> '/0' (값이 없음. 공백으로 초기화)
 * 
 * 				** new 연산자  => malloc() => 자주 사용하다 보니 연산자로 승격됨.
 * 				   ---------- => 넘겨주는 값(주소 int)
 * 				   ---------- => 동적 메모리 할당 (생성)
 * 								 ---------- 실행할 때 마다 메모리 확보 (메모리가 따로 생성이된다)
 * 								 ---------- 메모리 주소가 다르다 ==> 
 * 					int[] arr = new int[5];
 * 					arr = [I@1eb44e46 ====> 메모리 주소
 * 
 * 											연속적인 메모리를 가지고 있다
 * 										arr[0]	arr[1]	arr[2]	arr[3]	arr[4]	==> 인덱스를 이용하지만 실제로는 일반 변수 사용법과 동일하다.	
 *					arr ------------------> |---------------------------------
 *											 0	|	0	|	0	|	0	|	0
 *											|---------------------------------	같은 크기의 메모리가 5개 생성.
 *										[I@1eb44e46
 *										메모리 주소의 값
 *										=> 주소를 이용하여 원하는 데이터에 접근하는 변수 => 참조.
 *											대표적으로 배열 / 클래스가 이에 해당한다.
 *										=> 변수	 /	 배열 	/ 	클래스 ==> 배열과 클래스도 변수에 해당한다.
 *											|		   |		   |
 *										한 개만 저장    |		   |
 *													   |           |
 *										 	같은 데이터형 여러개     |
 *														다른 데이터형 여러개 저장
 *
 *										=> 예)
 *											학생 1명에 대한 정보
 *											-------------------
 *											1. 이름		
 *											2. 성별
 *											3. 학번
 *											4. 학년
 *											5. 주소
 *											6. 번호
 *											7. 나이
 *											-------------------
 *											변수 => 1.	String name1, name2, name3 ... ;
 *														=> String[] name = new String[3];
 *
 *														String sex1, sex2, sex3 ...;
 *														=> String sex = new String[3];
 *
 *														int hakbun1, hakbun2, hakbun3 ...
 *														=> int hakbun[] = new int[3];
 *											=> 클래스 (5장)
 *											class Student {
 *												String name, sex, address, phone;
 *												int hakbun, year, age;
 *											}
 *												==> 메모리를 원하는 만큼 확보 할 수 있다.
 *												Student hong0 = new Student()
 *												Student hong1 = new Student()
 *												Student hong2 = new Student()
 *												Student[] std = new Student[1000] ==> 이런 식으로 활용하면 1000명도 쉽게 가능하다.
 *
 *										=> 같은 데이터형이라면 배열이 쉽고 데이터형이 다르다면 클래스가 편한 경우가 많다.
			
 * 			3) 값 변경하는 방법
 * 				int[] arr = {10, 20, 30, 40, 50};
 * 
 * 				stack(주소를 가지고 있음)		Heap(실제 데이터가 저장되는 영역)
 * 				arr ------------------>		 [0]  [1]  [2]  [3]  [4]
 * 											 -----------------------
 * 					 						  10 | 20 | 30 | 40 | 50
 * 											|-----------------------		
 *										  0x100 0x104 0x108 0x112 0x116	(정수형이기 때문에 4byte씩 공간을 차지함)
 *									배열 변수는 시작 주소값만 가지고 있다.
 *									arr = 0x100
 *									arr[0] => 0x100 주소로부터 첫 번째 값
 *									arr[1] => 0x100 주소로부터 두 번째 값
 *									....
 *							세 번째 값 변경 => arr[2] = 100; ==> 30이 100으로 변경.
 *							마지막 값 변경  => arr[4] = 500; ==> 50이 500으로 변경.
 *							배열의 값을 변경할 때는  => 배열명[인덱스];
 *															-------- 0번부터
 *															-------- 개수 => length
 *							=>  배열 복사
 *								얕은 복사 : 공유할 때 사용
 *								깊은 복사 : 새로운 배열을 생성할 때 사용 (사용 빈도가 더 많음)
 * 
 * 			4) 출력하는 방법 / for-each
 */
public class 배열_1 {
	
	public static void main(String[] args) {
		// 메서드 => Call By Reference
		// 얕은 복사
/*
		int[] arr 	= {10, 20, 30, 40, 50};
		int[] temp	= arr;
		temp[0] = 100;
		temp[1] = 200;
		//arr[0] = 100, arr[1] = 200 ====> 주소에 값을 할당하여 사용하는 방식이기 때문에 같은 주소 안에 있는 값을 변경하면 arr[]의 값도 바뀐다.
		System.out.println("temp[0]" + temp[0]);
		System.out.println("temp[1]" + temp[1]);
		System.out.println("arr[0]" + arr[0]);
		System.out.println("arr[1]" + arr[1]);
*/
		int[] arr = {10, 20, 30, 40, 50};
		// 깊은 복사
		// 설정된 그대로 복사하여 새로운 배열에 생성하는 방식 => clone();
		// 배열은 메모리 주소를 이용하는 방식이다 => 주소를 대입하는 것은 별칭을 준다고 생각할 수 있다. (같은 메모리를 제어)
		int[] temp = arr.clone();	// 새로운 배열 생성
		int[] temp2 = arr;			// 얕은 복사이기 때문에 int[] arr과 같은 주소값을 공유한다.
		
		System.out.println("arr = " + arr);		// [I@6f2b958e
		System.out.println("temp = " + temp);	// [I@1f89ab83 ==> 혼자 다름.
		System.out.println("temp2 = " + temp2);	// [I@6f2b958e
		
		temp[0] = 100;
		temp[1] = 200;
		
		System.out.println("temp[0]" + temp[0]);
		System.out.println("temp[1]" + temp[1]);
		System.out.println("arr[0]" + arr[0]);
		System.out.println("arr[1]" + arr[1]);
		// 배열은 메모리 주소
		// => 원본이 변경될 수 있다.
		// 주소값은 대입이 가능하다. 
	}

}
