package com.sist.main;
/*
 * 	클래스 구성 요소
 * 	---------------
 * 	*** 클래스 블럭
 * 	class ClassName {
 * 		=>	구현 불가능. 
 * 			---- 제어문 / 연산 처리 / 파일 읽기 / 크롤링 / 메서드 호출 ... => 메서드 처리, 생성자. 초기화 블럭을 이용한다.
 * 
 * 		=>	선언만 가능한 부분
 * 
 * 
 * 			선언 가능한 목록
 * 		-------------------------------
 * 		1. 변수 
 * 		------------------------------- 한 개만 저장이 가능하다
 * 		2. 클래스 (사용자 정의 데이터 형)		
 * 		3. 배열
 * 		------------------------------- 여러 개 저장이 가능하다.
 * 			==>> 변수로 취급이 된다.
 * 	}
 * 	----------------------------------------------------------------------------------------------------
 * 		변수 : 프로그램에 필요한 데이터를 위한 저장 공간 => 프로그램 종료 시 까지 유지하는 변수 => 멤버 변수
 * 				=> 자동 초기화가 되어있다 (default 형식을 띄고 있음)
 * 	----------------------------------------------------------------------------------------------------
 * 		변수 => 초기화 (변수는 초기 값이 없는 상태에서는 메모리에 저장을 할 수 없다.)
 * 
 * 		생성자
 * 			=> 특징 (일반 메서드와 다르다)
 * 				1. 클래스 명과 동일해야 한다.
 * 
 * 				2. 리턴 형이 없다. (메서드는 메서드 이지만 리턴 형이 없음.) / (void 형도 결과 값이 없을 뿐 리턴 형을 가지고 있다.)
 * 					예)
 * 						class A {
 * 							void A(){} 	==> 일반 메서드 (void가 있음)
 * 							A(){}		==>	생성자
 * 						}
 *				3. 여러 개의 생성자를 만들 수 있다. 		
 *				   --------------- 같은 이름의 메서드를 여러 개 제작이 가능 (오버로딩)
 *					= 오버 로딩	: 같은 이름의 메서드로 새로운 기능을 추가할 때.
 *						1. 메서드 명이 동일해야 한다.
 *						2. 매개 변수의 개수나 데이터 형이 다르다.
 *						3. 리턴 형과는 관계가 없다.
 *						4. 접근 지정어와 관련이 없다.
 *						예)
 *							plusInt(int a, int b)			=> plus(int, int)
 *							plusDouble(double d, double d2)	=> plus(double, double)
 *							plusIntDouble(int a, double d)
 *							plusByteInt(byte b, int i)
 *							plusChar(char a, char b)
 *
 *				4. 생성자의 역할이 필요 없는 경우도 있기 때문에 생성자를 생략할 수 있다.
 *					** 반드시 생성자는 필요하다.
 *					** 생략이 된 경우에는 컴파일러가 자동으로 추가하여 생성 한다.
 *
 *					1)	멤버 변수의 초기화를 담당한다.
 *					2)	클래스를 메모리에 저장할 때 호출되는 메서드 이다.
 *						---------------------------------------------
 *					3)	시작과 동시에 처리해야 하는 기능이 있는 경우
 *						-------------------------
 *						=> 화면 UI, 오라클 연결, 서버 연결, 웹 => 자동 로그인
 *
 *				5. 생성자 호출
 *					=>	new 생성자()
 *						--- new 가 없이 호출되는 경우 에러가 발생한다.
 *
 * 		초기화 블럭 : 호출 없이 자동으로 처리한다.
 * 
 * 		인스턴스 변수 
 * 		{
 * 		구현 후 초기화
 * 		}
 * 
 *		정적 변수 
 *		static {
 *			static 변수의 초기화
 *		}
 *		
 *		** 초기화 방법
 *			1. 명시적인 초기화
 *				int a = 100;
 *		
 *			2. 초기화 블럭
 *				int a;
 *				{
 *					a = 100;	=> 파일 읽기, 웹 ==> 구현이 필요한 부분 (제어문, 반복문 등을 사용하는 경우)
 *				}
 *
 *			3. 생성자
 *				int a;
 *				생성자() {
 *					a = 100;	=> 파일 읽기, 웹 ==> 구현이 필요한 부분 (제어문, 반복문 등을 사용하는 경우)
 *				}
 *
 *				class A {
 *					int a = 10, b = 20, c = 30, d = 40, e = 50; ==> 0값 초기화 => 10 20 30 40 50
 *					=> random() ==> 초기화 블럭, 생성자
 *									------------------ => 반드시 필요한 부분이 아니기 때문에 필요한 경우에만 사용할 것.
 *				}
 *		** 명시적인 초기화를 가장 먼저 고려하고 불가한 경우 초기화 블럭, 생성자를 고려한다. 
 *
 *		==> 저장 되는 순서
 *		기본 값 ==> 명시적인 초기화 ==> 초기화 블럭 ==> 생성자
 *		--------------------------------------------------- ==> 동시에 사용하지 않고 셋 중 하나를 선택.
 *		예)
 *			class ClassName {
 *				int a = 100;	=>	중복이 없는 난수 값을 저장 => 명시적인 초기화가 불가능 (구현)
 *				{
 *					a = 200;
 *				}
 *
 *				ClassName() {
 *					a = 300;
 *				}
 *			}
 *		 a		 a		 a		 a
 *		---		---		---		---
 *		 0		100		200		300 ==> 프로그램을 시작하면 마지막 값인 300이 들어가기 때문에 대부분 int a = 300으로 값을 바로 주는 경우가 많다.
 *		
 *		클래스 영역에서는 선언과 동시에 초기화만 가능하다.
 *		int a;
 *		int a = 100; // int a = 100;	===> 가능
 *		
 *		int a;
 *		a = 100	====> 불가능	
 * 	----------------------------------------------------------------------------------------------------
 * 	메서드 :	특정 기능을 수행하는 명령문의 집합
 * 			--------
 * 			검색, 목록, 페이지 나누기, 예약, 결제, 회원 가입, 회원 탈퇴
 * 
 * 			1. 재사용이 좋다.
 * 			2. 기능 별로 나눠져있어 => 수정하기 편리하다.
 * 			3. 반복 기능을 제거할 수 있다.
 * 			4. 구조적인 프로그램을 만들 수 있다. (2번과 동일)
 * 			5. 역할 : 기능을 수행하거나, 다른 클래스와 연결하는 역할을 한다
 * 										------------------------ ** 핵심
 * 			=>	객체 지향 프로그램 
 * 				여러 개를 모아서 조립하는 프로그램 => 다른 클래스와 연동.
 * 	기능
 * 		CPU / HD / monitor / memory ==> 기능을 구현
 * 		---------------------------
 * 					|
 * 				main board
 * 		=> 클래스 1개 == 부품 => 조립 (CBD)
 * 									Component : 클래스 (한 개의 기능) ===>> 메서드가 여러 개 묶이면 한 개의 컴포넌트라고 한다.)
 * 									=> 여러 개 만들어 => 조립 => 레고와 같은 개념
 * 									=> 묶어주는 역할 : Container
 * 		=> 메서드 형식
 * 			[접근 지정어] [옵션 지정어] 리턴형 메서드명 (매개 변수) => 선언부
 * 			{						  ------ 데이터 형
 * 				구현부
 * 				return 값	=> 데이터 형과 리턴 형이 일치해야 함.
 * 				void (결과 값이 없는 경우) => return; 생략이 가능.
 * 											 ------------------
 * 											(컴파일러가 자동으로 추가)
 * 			}
 * 		** 접근 지정어
 * 			private		: 자신의 클래스 안에서만 사용이 가능하다. => 다른 클래스와 연결할 수 없다. => 멤버 변수가 주로 해당 (데이터를 보호해야 하기 때문에)
 * 															  ---------------------------- 객체 지향성이 떨어짐.
 * 			default		: 키워드가 없는 상태 => 같은 패키지 안에서만 접근이 가능하다.
 * 			protected	: 같은 패키지 안에서만 접근이 가능 + 상속을 받은 경우에는 다른 패키지 접근이 가능하다.
 * 			public		: Open 모드 => 패키지와 관계 없이 모든 클래스에서 접근이 가능하다.
 * 			==================================================================================================
 * 			private	: 접근 거부 => 다른 클래스에서 사용이 안됨. => 개인 정보가 이에 해당되는 경우가 많고 => 코드에서는 멤버 변수에 해당되는 경우가 많음.
 * 				=> 메서드 (변수의 기능)
 * 						  -----------
 * 						  메모리 저장 / 메모리 값 읽기
 * 						  ----------   -------------
 * 							setter			getter
 * 						public setXxx()	public getXxx()  ==> Xxx는 변수명
 * 						=> 변수는 메모리에 값이 저장 => 변수는 값을 지정하기 때문에 데이터 노출의 우려가 있음 (변경, 상실 방지) => 노출이 되면 데이터의 변경 / 상실이 생길 수 있다.
 * 						=> 메서드는 주소 값만 저장되어 있기 때문에 데이터가 노출되지 않는다. (데이터는 주소 값 안에 저장되어 있지만 메서드는 값이 아닌 주소 값이 저장되어 있음)
 * 						--------------------------------------------------------------------- ==> 캡슐화
 * 
 * 			public	: 접근 가능 => 다른 클래스와 연결이 가능함  => 생성자 / 클래스 / 메서드 / 인스턴스 / ... 
 * 			-----------------------------------------------
 * 			접근 지정어 사용 방법
 * 			-------------------
 * 			클래스
 * 			[접근 지정어] [옵션 지정어] class ClassName
 * 			------------  -----------
 * 				  |				| => static / abstract / final
 * 				  |
 * 				public => 다른 클래스와 연결
 * 
 * 			{
 * 				=> 구현
 * 			}
 * 
 * 			멤버 변수
 * 			[접근 지정어] [옵션 지정어] 데이터 형 변수 명 => 클래스, 배열
 * 			 ----------	  ----------
 * 				 |			static : 공통으로 사용하는 변수 => 메모리 공간 1개만 만든다. (Method Area / Class Area)
 * 				 |
 * 				 |=> private : 개인 정보, 회사 정보 => 노출하면 안되는 정보
 * 				 |=> public	 : 라이브러리 클래스, 버튼, 테이블 => 연결
 * 							   윈도우와 관련.
 * 			**  일반	=> 인스턴스
 * 			**  데이터 묶음 => static => 데이터 관리
 * 				회원 목록 / 게시판 목록 => 한 개만 가지고 사용
 * 		------------------------------------------------------------------------------------------------
 * 		메서드 : 다른 클래스와 연결
 * 				----------------- =>요청 결과 값
 * 														|=> 사용자 요청 값
 * 		[접근 지정어] [옵션 지정어] 리턴 형 메서드 명 (매개 변수)
 * 		-----------	  ----------  ------			-------- => 매개 변수가 3개 이상이면 배열 / 클래스를 사용한다.
 * 			 |			   |		| => 기본형, 배열, 클래스
 * 			 |			   |		
 * 		   public		static	 => 공통으로 사용되는 것 (한글 변환, 암호화, 복호화, ...)
 * 						abstract 
 * 		{
 * 			구현
 * 		}
 * 
 * 		=> 경우의 수
 * 		-------------------------------------
 * 			리턴형				매개 변수
 * 		  요청 처리 값		  사용자 요청 값
 * 		-------------------------------------
 * 			  O						O  ==>	String
 * 											String substring(int s, int e)
 * 											s 부터  e 까지 자른 문자열을 받음.
 * 		-------------------------------------
 * 			  O						X	=>	String trin()		=> 공백을 제거한 문자열
 * 										=>	String toUpperCase	=> 대문자로 변환 후 문자열로 받음 	
 * 		-------------------------------------
 * 			  X						O	=>	void System.out.println(String s)
 * 											s 를 출력하라
 * 												=> 메서드 자체 처리 => 결과 값이 없다 void
 * 												=> 오라클에 추가, 수정, 삭제
 * 		-------------------------------------
 * 			  X						X	=>	사용 빈도가 거의 없다.
 * 											void System.out.println() => 출력 후 줄바꿈	 
 * 		-------------------------------------
 * 
 * 		** 옵션 지정어
 * 			=> 메서드 호출
 * 			class A {
 * 				private int a;
 * 				private int b;
 * 				private static int c;		=> 저장
 * 				public void aaa(){}
 * 				public static void bbb(){}	=> 저장
 * 				public int ccc(){}
 * 				public static int ddd(){}	=> 저장
 * 							  ---
 * 							  int / long / double 형으로 받을 수 있지만 => 같은 데이터 형으로 받는 것을 권장한다.
 * 			}
 * 				static => 메서드 / 변수는 컴파일 시에 저장
 * 			-------------
 * 				-----
 * 				  0  ===> c		====>	A.c => 클래스 명. 변수
 * 				-----
 * 				bbb()			====>	A.bbb() => 클래스 명. 메서드 명()
 * 				-----
 * 				ddd()			====>	결과 값을 받는다
 * 				-----					int result = A.ddd();
 * 			-------------				---			 ------- 리턴 형이 있는 경우에는 결과 값을 받아서 저장해야 한다.
 * 										 |
 * 										 |=> 리턴에 사용된 데이터 형 보다 크거나 같아야 한다.
 * 			A aa = new A();
 * 
 * 				Stack					
 * 			---- aa ----		
 * 				0x100	=> 메모리 주소에 있는 변수 / 메서드를 가지고 온다 => . => aa. ( .은 메모리 주소 접근 연산자이다.)				 
 * 			------------					
 * 											Heap
 * 								0x100	------------
 * 										  --------
 * 											 0 ----> a		==> 객체 명. 변수 명	  ===> aa.a
 * 										  --------
 * 											 0 ----> b		==>	객체 명. 변수 명	  ===> aa.b
 * 										  --------
 * 											aaa() ----> b	==> 객체 명. 메서드 명 ===> aa.aaa()
 * 										  --------
 * 											ccc() ----> b	==> 객체 명. 메서드 명 ===> aa.ccc()
 * 										  --------
 * 										------------
 * 		메서드 수행
 * 		----------
 * 		public int aaa() {
 * 			1.	문장
 * 			2.	문장
 * 			3.	문장
 * 			return 10;
 * 		}
 * 
 * 		int a = aaa() => 호출
 * 		1.	문장
 * 		2.	문장
 * 		3.	문장
 * 		=======================> a에 10을 대입한다 === 밑에 문장 수행
 * 
 * 		호출 => 메서드에 있는 모든 문장을 수행 후 => 호출된 위치 복귀
 * 		-----------------------------------------------------------
 * 		** 메서드는 호출 시 마다 => 메서드 처음부터 다시 수행한다.
 * 
 * 	----------------------------------------------------------------------------------------------------
 * 	=> 패키지 / 임포트
 * 	=> 데이터 보호 : 캡슐화
 * 	=> 상속 / 포함
 * 	=> 오버라이딩 / 오버로딩
 * 	----------------------- 객체 지향 프로그램
 * 	예외 처리 / 클래스 종류 / 라이브버리 사용 / 구현
 * 
 * 	**** 개념 : 면접
 * 		=>	1. 형식 / 2. 사용 방식 / 3. 조립 => 기능
 * 						------- 메서드 호출 / 초기화
 * 			--------------------------------------- 요구 사항 분석 => 구글링 / GPT
 * 	개념 =>	자바 / Spring
 * 			---- 객체 지향 프로그램 / 자료 구조
 * 	----------------------------------------------------------------------------------------------------
 */

public class 클래스구성요소_변수 {
	// 저장이 안된 상태 => 인스턴스 (new 를 이용해서 저장한다)
	/*
	 * 인스턴스 : 객체 ------- 클래스의 내용(메서드, 변수) => 메모리에 저장한 상태 => 각자 따로 저장 => new 를 이용해야
	 * 사용이 가능
	 * 
	 * 인스턴스 : 변수 / 메서드 (********) static : 변수 / 메서드
	 * 
	 * class A { private int a = 10; => 객체 자신이 가지고 있는 변수. private static int b = 20;
	 * => 객체마다 공통으로 사용되는 변수.
	 * 
	 * public void aaa() { => 객체 자신이 가지고 있는 메서드
	 * 
	 * => ccc() / a / b 사용이 가능하다. } public static void bbb() { => 객체마다 공통으로 사용되는 메서드
	 * 
	 * => b 하나만 사용이 가능하다. => static 에서는 static 으로 선언된 변수, 메서드만 사용이 가능하다.
	 * 
	 * => aaa(), bbb(), a를 사용하려고 한다면 A aa = new A(); ==> 객체를 선언한 후에 사용이 가능하다.
	 * aa.aaa() aa.bbb() aa.a } public void ccc() { => 객체 자신이 가지고 있는 메서드
	 * 
	 * => aaa() / a / b 사용이 가능하다 } 인스턴스 메서드는 클래스에 있는 모든 데이터 / 메서드를 사용할 수 있다.
	 * 
	 * 메서드는 호출이 되면 return;이 있는 곳 까지 수행한다. }
	 */
	public void aaa() {
		System.out.println("aaa() 진입 ...");
		bbb();
		System.out.println("aaa() 종료 ...");
	}

	public void bbb() {
		System.out.println("bbb() 진입 ...");
		ccc();
		System.out.println("bbb() 종료 ...");
	}

	public void ccc() {
		System.out.println("ccc() 진입 ...");
		System.out.println("ccc() 종료 ...");
	}

	public static void main(String[] args) {
		// 객체를 생성 후 호출한다 => static 에서는 static 만 호출할 수 있기 때문에.
		클래스구성요소_변수 aa = new 클래스구성요소_변수(); // 클래스명 메서드명 = new 클래스명() 으로 객체를 생성 해주어야 한다.
											// ------------ 생성자
		aa.aaa();

	}

}
