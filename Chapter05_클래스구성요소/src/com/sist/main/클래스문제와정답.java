package com.sist.main;
/*	1. 객체와 클래스에 대한 설명으로 틀린 것은 무엇입니까?					정답 : 3번	//	new를 이용하면 여러 개의 객체를 생성할 수 있다.`
 *		1) 클래스는 객체를 생성하기 위한 설계도(청사진)와 같은 것이다.
 *		2) new 연산자로 클래스의 생성자를 호출함으로써 객체가 생성된다. 
 *		----------------------------------------------
 *		3) 하나의 클래스로 하나의 객체만 생성할 수 있다.
 *		----------------------------------------------
 *		4) 객체는 클래스의 인스턴스이다.	
 *		
 *		
 *==================================================================
 *	2. 클래스의 구성 멤버가 아닌 것은 무엇입니까?							정답 : 4번	//	4)은 final만 유일하게 사용이 가능하다.
 *		1) 필드(field)	
 *		2) 생성자(constructor)				
 *		3) 메소드(method)
 *		----------------------------
 *		4) 로컬 변수(local variable)
 *		----------------------------
 * 		
 * 		
 * 		1), 2), 3)은 접근 지정어, 옵션 지정어가 사용이 가능하다.
 * 
 * 		클래스의 구성 요소
 * 		-----------------
 * 		멤버 변수	== 필드
 * 		-----------------
 * 		생성자
 * 		-----------------
 * 		메서드		=> 안에 선언 => 지역 변수 (접근 지정어가 필요 없음)
 * 		-----------------
 * =====================================================================
 *	3. 필드, 생성자, 메소드에 대한 설명으로 틀린 것은 무엇입니까?			정답 : 4번	//	반드시(x) 메서드가 없을 수 있다.
 *		1) 필드는 객체의 데이터를 저장한다.
 *		2) 생성자는 객체의 초기화를 담당한다
 *		3) 메소드는 객체의 동작 부분으로, 실행 코드를 가지고 있는 블록이다.
 *			메서드 {
 *				-- 실행 코드
 *			}
 *		---------------------------------------------
 *		4) 클래스는 반드시 필드와 메소드를 가져야 한다.
 *		---------------------------------------------
 *		클래스의 종류
 *			= 데이터 형 클래스 : 사용자 정의 데이터형	=> 관련된 데이터를 한번에 모아서 전송 => 웹
 *				=> 변수만 설정
 *					class Student {
 *						String name;
 *						String subject;
 *						...
 *						...
 *					}
 *
 *			= 액션 클래스 : 동작
 *				=> 메서드만 설정
 *			-------------------- + 혼합
 *			멤버 변수	: 데이터를 저장할 목적으로 만든 것.
 *			메서드		: 멤버 변수를 어떻게 활용할 지 만든 것 => 동적인 성향을 띄고 있다.
 *			생성자		: 멤버 변수의 초기화, 객체 생성시에 호출하는 것
 * =================================================================================	
 *	 4. 필드에 대한 설명으로 틀린 것은 무엇입니까?							정답 : 3번 // 필드, 생성자, 메서드 순이 권장 사항. 각각의 순서가 바뀌어도 오류는 아니다.
 * 		1) 필드는 메소드에서 사용할 수 있다.
 * 		2) 인스턴스 필드 초기화는 생성자에서 할 수 있다.
 * 		---------------------------------------------------------
 * 		3) 필드는 반드시 생성자 선언 전에 선언되어야 한다.
 * 		---------------------------------------------------------
 * 		4) 필드는 초기값을 주지 않더라고 기본값으로 자동 초기화된다.
 * 
 * 		멤버 변수
 * 			=> 초기화 (생성자)
 * 			=> 활용	=> 메서드
 * 			=> 기본 값을 가지고 있다
 * 
 * 			class A {
 * 				int	a;		===> 0
 * 				double	b;	====> 0.0
 * 				boolean	c;	====> false
 * 				String	d;	====> null
 * 			}
 * 			
 * 			class A {
 * 			-------------------------
 * 				멤버 변수 (필드)
 * 			------------------------
 * 				생성자
 * 			------------------------
 * 				메서드		==> 권장 사항. 각각의 순서가 바뀌어도 오류는 아니다.
 * 			-----------------------
 * ====================================================================================
 * 	5. 생성자에 대한 설명으로 틀린 것은 무엇입니까?								정답 :	1번	// 그러나 new 가 없어도 메모리 할당이 가능하게 하는 리플렉션이 있어서 정답이 없는 문제이다.
 * 		-----------------------------------------------------------------
 * 		1) 객체를 생성하려면 생성자 호출이 반드시 필요한 것은 아니다.	
 * 		-----------------------------------------------------------------
 * 		2) 생성자는 다른 생성자를 호출하기 위해 this()를 사용할 수 있다.
 * 		3) 생성자가 선언되지 않으면 컴파일러가 기본 생성자를 추가한다.
 * 		4) 외부에서 객체를 생성할 수 없도록 생성자에 private 접근 제한자를 붙일 수 있다.
 * 
 * 		생성자 => 여러 개 사용이 가능, 없는 경우도 존재 (자동 컴파일러에 의해 추가된다)
 * 													=> 한 개라도 존재한다면 추가하지 않는다.
 * 		생성자가 3개일 때.
 * 			class A { 
 * 				A(){}				==> 매개 변수가 없는 생성자만 추가한다 => default 생성자.
 * 				A(int a){}
 * 				A(int a, int b){}
 * 			}
 * 
 * 		생성자가 2개일 때
 * 			class A {				==> 2개의 생성자 모두 매개 변수가 있어 자동으로 추가하지 않음.
 * 				A(int, a){}
 * 				A(int a, int b){}
 * 			}
 * 
 * 		생성자가 없는 경우
 * 			class A{
 * 				=> 자동 추가 => A(){}
 * 			}
 * =============================================================================================
 * 	6. 메소드에 대한 설명으로 틀린 것은 무엇입니까?									정답 :	4번	//	메서드는 오버 로딩이 가능하다 : 중복 메서드 정의
 * 		1) 리턴값이 없는 메소드는 리턴 타입을 void로 해야 한다.												---------				1) 메서드 명이 동일해야 한다.
 * 		2) 리턴 타입이 있는 메소드는 리턴값을 지정하기 위해 반드시 return문이 있어야 한다.											2) 매개 변수의 개수나 데이터 형이 다르다
 * 		3) 매개값의 수를 모를 경우 "..."를 이용해서 매개 변수를 선언할 수 있다.														3) 리턴 형과는 관계가 없다
 * 								  ----	가변 매개 변수 printf("%d%d%d", 1, 2, 3)													4) 접근 지정어도 관계가 없다.
 * 													  printf(
 * 		----------------------------------------
 * 		4) 메소드의 이름은 중복해서 선언할 수 없다.
 * 		----------------------------------------
 * 		메서드 :	기능 처리
 * 				반복 제거
 * 				재사용
 * 				다른 클래스와 연결
 * 	
 * 		[접근지정어] 리턴 형 메서드 명(매개 변수 목록)
 * 		---------- 다른 클래스와 연결 => public
 * 		{
 * 			처리 문장 => 사용자가 요청한 내용을 처리
 * 			=> 결과 값 전송
 * 			return	값;
 * 				 	--- 결과 값이 없는 경우 => 리턴 형 : void, return; ==> return 은 생략이 가능하다.
 * 
 * 				메서드가 저장되는 형태
 * 		void disp()				=> disp()
 * 		void disp(int a)		=> disp(int)
 * 		int disp(int a, int b)	=> disp(int, int)	-------|
 * 		int disp(double d)		=> disp(double)			   | => 저장 되는 형식이 같이 때문에 매개 변수가 다른 것으로는
 * 		int disp(int c, int k)	=> disp(int, int)	-------|	오버로딩이 되지 않는다. (같은 메서드로 인식)
 * 	===================================================================================================	
 * 	7. 메소드 오버로딩에 대한 설명으로 틀린 것은 무엇입니까?						정답 :	2번	//	리턴 타입이 달라도 각 매개 변수가 순서대로 해당 값을 찾아간다.
 * 		1) 동일한 이름의 메소드를 여러 개 선언하는 것을 말한다.
 * 		---------------------------------------------------------
 * 		2) 반드시 리턴 타입이 달라야 한다.
 * 		---------------------------------------------------------
 * 		3) 매개 변수의 타입, 수 순서를 다르게 선언해야 한다.
 * 		4) 매개값의 타입 및 수에 따라 호출될 메소드가 선택된다.
 * 
 * 		void aaa(){}
 * 		void aaa(int a){}
 * 		void aaa(int a, int b){}
 * 		int aaa(double d1, double d2){}
 * 
 * 		aaa(10.0, 20.0)
 * ==========================================================================================================
 * 8. 인스턴스 멤버와 정적 멤버에 대한 설명으로 틀린 것은 무엇입니까?				정답 : 2번	// 인스턴스 필드는 static 메서드, static 변수를 사용할 수 없다.
 * 		1) 정적 멤버는 static으로 선언된 필드와 메소드를 말한다.									static 을 사용하려면 객체를 생성한 후 사용할 수 있다.
 * 		-----------------------------------------------------------------------					(반대로 static 에서는 static 만 사용할 수 있다)
 * 		2) 인스턴스 필드는 생성자 및 정적 블록에서 초기화될 수 있다.
 * 		-----------------------------------------------------------------------
 * 		3) 정적 필드와 정적 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있다.
 * 		4) 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다.
 * 
 * 		class A {
 * 			static int a = 10;		==> 저장
 * 			int b = 20;		==> 저장 안됨
 * 			static void disp(){}	==> 저장
 * 			void aaa(){}	==> 저장 안됨
 * 		}
 * 
 *		A.a / A.disp() 
 *		클래스 명으로 접근이 가능하다(변수, 메서드) => Math.random()
 *													------------- Math math = new Math()로 사용하지 않았기 때문에
 *																  static이라는 것을 알 수 있다.	
 * 		A aa = new A();
 * 		  -- b, aaa()
 * 		aa.b, aa.aaa()
 * 
 * 		class A {
 * 			{
 *  			int a;
 * 				static int b;
 * 			}
 * 			static {
 * 
 * 			}
 * 		}
 * ==================================================================================================================
 *	9. final 필드와 상수(static final)에 대한 설명으로 틀린 것은 무엇입니까?		정답 : 2번	//	상수(static final)는 선언과 동시에 초기 값을 부여해야 한다.
 *		1) final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없다.								** 상수형 변수(final)는 선언만 한 후 나중에 초기화가 가능하다 **
 *		-----------------------------------------------------------
 *		2) final 필드와 상수는 생성자에서 초기화될 수 있다.
 *		-----------------------------------------------------------
 *		3) 상수의 이름은 대문자로 작성하는 것이 관례이다.
 *		4) 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다.
 *			=> static 이기 때문에 객체 생성 없이 클래스를 통해 사용할 수 있다.
 *	
 * 		상수	 =>	상수 (static final) 두 가지로 나뉘어져 있다.
 * 				상수형 변수 (final)
 * 					  |=> 상수형 변수는 선언만 한 후 나중에 초기화가 가능하다.
 * ==================================================================================================
 *	10. 다음 클래스에서 해당 멤버가 필드, 생성자, 메소드 중 어떤 것인지 빈칸을 채우세요.		정답 :	필드		==>
 * 	public class Member {																		생성자	==>
 *    	private String name; // -------------------------------------(  (1)  )  				메서드	==>
 *  
 *     		public Member(String name) { } // ---------------------------(  (2)  )
 *    
 *   		public void setName(String name) { } // ---------------------(  (3)  )
 * 	}
 * 	
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * =====================================================================================================
 *	11. 현실 세계의 회원을 Member 클래스로 모델링하려고 합니다. 
 *		회원의 데이터로는 이름, 아이디, 패스워드, 나이가 있습니다. 
 *		이 데이터들을 가지는 Member 클래스를 선언해보세요
 * 
 * 		 데이터 이름	 필드 이름 	 타입 
 * 			이름 	 	name 	문자열 
 * 			아이디		 id	 	문자열 
 * 			패스워드	 password	문자열 
 * 			나이	 		age	 	정수 
 *
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * =======================================================================================================
 *	12.	위에서 작성한 Member 클래스에 생성자를 추가하려고 합니다. 다음과 같이 Member 객체를 생성할 때 
 *		name 필드와 id 필드를 외부에서 받은 값으로 초기화하려면 생성자를 어떻게 선언해야 합니까?
 *		** 캡슐화로 만드시오 **
 *
 *		=> 다음과 같은 멤버 변수를 가즌 SutdaCard 클래스를 정의하시오.
 *		type		변수 명		설명
 *		-------------------------------------------------------------
 *		int			num			카드의 숫자. (1 ~ 10 사이의 정수)
 *		boolean		isKwng		광이면 true, 아니면 false
 *		-------------------------------------------------------------
 *
 *		=> 다음과 같은 멤버 변수를 갖는 Sutdent 클래스를 정의하시오.
 *		
 *		String		name		학생 이름
 *		int			ban			반
 *		int			no			번호
 *		int			kor			국어 점수
 *		int			eng			영어 점수
 *		int			math		수학 점수
 *		
 * 		=> 다음의 코드에 정의된 변수들을 종류별로 구분해서 적으시오
 * 		class PlayintCard {
 * 			int kind;
 * 			int num;
 * 			static int width;
 * 			static int height;
 * 
 * 			PlayingCard(int k, int n) {
 * 				kind = k;
 * 				num	= n;
 * 			}
 * 			인스턴스 변수
 *			정적 변수 (공유 변수)
 *			지역 변수
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * ==========================================================================================================
 * 	다음 중 생성자에 대한 설명으로 옳지 않은 것은? (모두 고르시오)
 * 		a. 모든 생성자의 이름은 클래스의 이름과 동일해야한다.
 * 		b. 생성자는 객체를 생성하기 위한 것이다.
 * 		c. 클래스에는 생성자가 반드시 하나 이상 있어야 한다.
 * 		d. 생성자가 없는 클래스는 컴파일러가 기본 생성자를 추가한다.
 * 		e. 생성자는 오버로딩 할 수 없다.
 *
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * ============================================================================================================
 *	다음 중 초기화에 대한 설명으로 옳지 않은 것은? (모두 고르시오)
 * 		a. 멤버변수는 자동 초기화되므로 초기화하지 않고도 값을 참고할 수 있다.
 *		b. 지역변수는 사용하기 전에 반드시 초기화해야 한다.
 *		c. 초기화 블럭보다 생성자가 먼저 수행된다.
 *		d. 명시적 초기화를 제일 우선적으로 고려해야 한다.
 *		e. 클래스변수보다 인스턴스변수가 먼저 초기화된다.
 * ==========================================================================================================
 *	다음 중 인스턴스변수의 초기화 순서가 올바른 것은?
 *		a. 기본값-명시적초기화-초기화블럭-생성자
 *		b. 기본값-명시적초기화-생성자-초기화블럭
 *		c. 기본값-초기화블럭-명시적초기화-생성자
 *		d. 기본값-초기화블럭-생성자-명시적초기화
 * ==========================================================================================================
 *	다음 중 지역변수에 대한 설명으로 옳지 않은 것은? (모두 고르시오)
 *		a. 자동 초기화되므로 별도의 초기화가 필요없다.
 *		b. 지역변수가 선언된 메서드가 종료되면 지역변수도 함께 소멸된다.
 *		c. 메서드의 매개변수로 선언된 변수도 지역변수이다.
 *		d. 클래스변수나 인스턴스변수보다 메모리 부담이 적다.
 *		e. 힙(heap)영역에 생성되며 가비지 컬렉터에 의해 소멸된다.
 * ============================================================================================================
 *	다음 중 접근제어자를 접근범위가 넓은 것에서 좁은 것의 순으로 바르게 나열한 것은?
 *		a. public-protected-(default)-private
 *		b. public-(default)-protected-private
 *		c. (default)-public-protected-private
 *		d. private-protected-(default)-public
 *		접근 제어자가 사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
 *		(     ) - 같은 클래스 내에서만 접근이 가능하다.
 *		(     ) - 같은 패키지 내에서만 접근이 가능하다.
 *		(     ) - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능하다.
 *		(     ) - 접근 제한이 전혀 없다.
 * ===========================================================================================================
 *	다음 중 접근 제어자에 대한 설명으로 옳지 않은 것은? (모두 고르시오)
 *		a. public은 접근제한이 전혀 없는 접근 제어자이다.
 *		b. (default)가 붙으면, 같은 패키지 내에서만 접근이 가능하다.
 *		c. 지역변수에도 접근 제어자를 사용할 수 있다.
 *		d. protected가 붙으면, 같은 패키지 내에서도 접근이 가능하다.
 *		e. protected가 붙으면, 다른 패키지의 자손 클래스에서 접근이 가능하다.
 *
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * ================================================================================================================
 */
/*class A {
	public void display() {
		System.out.println("display call..");
	}
}
*/	

class A {
	public void display(int ...arg) {
		for (int i : arg) {
			System.out.println(i + " ");
		}
	}
}
public class 클래스문제와정답 {

	public static void main(String[] args) throws Exception {
/*		//	리플렉션 => Spring 자체에서 메모리를 할당해서 사용하는 방식.
		Class className = Class.forName("com.sist.main.A");
		Object obj = className.getDeclaredConstructor().newInstance();
		
		A a = (A)obj;
		a.display();
*/
		A a = new A();
		a.display(1, 2, 3, 4, 5);
		a.display(1, 2);
		a.display(1, 2, 3, 4, 5, 5, 4, 3, 2, 3, 4, 5, 1, 23, 4, 123, 4, 5, 2);
		
	}

}
